<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Crawler Control</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }
        
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0,0,0,0.8);
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 100;
            gap: 12px;
        }

        #header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #header-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }

        .toggle-container span {
            color: #bbb;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: 0.2s;
            border-radius: 12px;
        }

        .toggle-slider::before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: #fff;
            transition: 0.2s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #4CAF50;
        }

        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(22px);
        }

        .btn {
            background: #333;
            color: #fff;
            border: none;
            padding: 10px 15px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .btn:hover { background: #555; }
        .btn.active { background: #4CAF50; }
        .btn.emergency { background: #d32f2f; }
        .btn.shutdown { background: #f57c00; }

        #quality-select {
            background: #222;
            color: #fff;
            border: 1px solid #444;
            padding: 8px 10px;
            border-radius: 4px;
        }

        #video-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #111;
        }
        
        #camera-start-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 50;
        }
        
        #camera-start-overlay button {
            padding: 20px 40px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        #camera-start-overlay button:hover {
            background: #5CBF60;
        }
        
        #front-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none;
            transform: scaleY(-1);
        }
        
        #rear-video {
            position: absolute;
            top: 90px;
            right: 20px;
            width: 320px;
            height: 240px;
            border: 2px solid #444;
            border-radius: 10px;
            background: #222;
            display: none;
            object-fit: cover;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
        }

        .camera-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #f44336;
            display: none;
        }
        
        .hidden {
            display: none !important;
        }

        .control-slider {
            position: fixed;
            width: 60px;
            height: 400px;
            background: rgba(255,255,255,0.1);
            border-radius: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-slider.left { left: 20px; bottom: 100px; }
        .control-slider.right { right: 20px; bottom: 100px; }

        #joystick-control {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 14px;
        }

        #joystick-base {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: rgba(255,255,255,0.08);
            border: 2px solid rgba(255,255,255,0.18);
            position: relative;
            touch-action: none;
            box-shadow: inset 0 10px 25px rgba(0,0,0,0.35);
        }

        #joystick-base.active {
            background: rgba(76,175,80,0.18);
            border-color: rgba(76,175,80,0.45);
        }

        #joystick-thumb {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #4CAF50;
            border: 3px solid #fff;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 12px 25px rgba(0,0,0,0.4);
            transition: transform 0.12s ease-out;
        }

        .joystick-label {
            font-size: 12px;
            letter-spacing: 2px;
            color: rgba(255,255,255,0.7);
        }

        .slider-track {
            width: 40px;
            height: 375px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            position: relative;
        }

        .slider-thumb {
            width: 36px;
            height: 36px;
            background: #4CAF50;
            border-radius: 50%;
            position: absolute;
            left: 2px;
            top: 0;
            cursor: pointer;
            border: 2px solid #fff;
        }
        
        .control-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 12px;
        }
        
        #status {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 5px;
            font-size: 14px;
        }
        
        .camera-status {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-dot.active { background: #4CAF50; }
        .status-dot.inactive { background: #f44336; }
    </style>
</head>
<body>
    <div id="header">
        <div id="header-left">
            <h2>ü§ñ Crawler</h2>
            <span id="connection-status">Disconnected</span>
        </div>
        <div id="header-controls">
            <label for="quality-select" style="font-size: 12px;">Stream:</label>
            <select id="quality-select" onchange="changeStreamQuality(this.value)">
                <option value="balanced">Balanced</option>
                <option value="low">Low Lag</option>
                <option value="high">High Detail</option>
            </select>
            <div class="toggle-container" title="Toggle control scheme">
                <span>Tank</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="control-toggle" onchange="onControlToggle(this.checked)">
                    <span class="toggle-slider"></span>
                </label>
                <span>Joystick</span>
            </div>
            <button id="camera-btn" class="btn" onclick="toggleCamera()">üìπ Camera</button>
            <button class="btn emergency" onclick="emergencyStop()">üõë STOP</button>
            <button class="btn shutdown" onclick="shutdownCrawler()">‚èª Shutdown</button>
        </div>
    </div>
    
    <div id="video-container">
        <div id="camera-start-overlay">
            <button onclick="startCameras()">üìπ Start Cameras</button>
            <p style="margin-top: 20px; color: #999;">Click to start camera streams</p>
        </div>
        
        <div class="camera-error" id="camera-error">
            <h3>Camera Error</h3>
            <p id="error-message"></p>
            <button class="btn" onclick="retryCameras()">Retry</button>
        </div>
        
        <img id="front-video" alt="Front Camera">
        <img id="rear-video" alt="Rear Camera">
        
        <div class="camera-status" id="camera-status" style="display: none;">
            <div><span class="status-dot" id="front-status"></span>Front Camera</div>
            <div><span class="status-dot" id="rear-status"></span>Rear Camera</div>
        </div>
    </div>
    
    <div id="tank-controls">
        <div class="control-slider left">
            <div class="slider-track">
                <div class="slider-thumb" id="left-thumb"></div>
            </div>
            <div class="control-label">LEFT</div>
        </div>

        <div class="control-slider right">
            <div class="slider-track">
                <div class="slider-thumb" id="right-thumb"></div>
            </div>
            <div class="control-label">RIGHT</div>
        </div>
    </div>

    <div id="joystick-control" class="hidden">
        <div id="joystick-base">
            <div id="joystick-thumb"></div>
        </div>
        <div class="joystick-label">JOYSTICK</div>
    </div>
    
    <div id="status">Speed: L=0% R=0%</div>
    
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // WebSocket connection
        const socket = io();
        let camerasActive = false;
        let frontCameraActive = false;
        let rearCameraActive = false;
        let motorSendScheduled = false;
        let lastMotorSend = 0;
        const MOTOR_COMMAND_INTERVAL = 60; // ms
        const SPEED_CURVE_EXPONENT = 2.4;
        const SPEED_DEAD_ZONE = 8;

        socket.on('connect', () => {
            document.getElementById('connection-status').textContent = 'Connected';
            document.getElementById('connection-status').style.color = '#4CAF50';
        });
        
        socket.on('disconnect', () => {
            document.getElementById('connection-status').textContent = 'Disconnected';
            document.getElementById('connection-status').style.color = '#f44336';
        });
        
        // Camera management
        function startCameras() {
            console.log('Starting cameras...');
            document.getElementById('camera-start-overlay').style.display = 'none';
            document.getElementById('camera-error').style.display = 'none';
            
            // Start front camera
            const frontVideo = document.getElementById('front-video');
            frontVideo.onerror = function() {
                console.error('Front camera failed to load');
                document.getElementById('front-status').className = 'status-dot inactive';
                frontCameraActive = false;
                checkCameraStatus();
            };
            
            frontVideo.onload = function() {
                console.log('Front camera loaded');
                frontVideo.style.display = 'block';
                document.getElementById('front-status').className = 'status-dot active';
                frontCameraActive = true;
                camerasActive = true;
            };
            
            // Add timestamp to force reload
            frontVideo.src = '/video_feed/front?' + Date.now();
            
            // Start rear camera with delay
            setTimeout(() => {
                const rearVideo = document.getElementById('rear-video');
                rearVideo.onerror = function() {
                    console.error('Rear camera failed to load');
                    document.getElementById('rear-status').className = 'status-dot inactive';
                    rearCameraActive = false;
                };
                
                rearVideo.onload = function() {
                    console.log('Rear camera loaded');
                    rearVideo.style.display = 'block';
                    document.getElementById('rear-status').className = 'status-dot active';
                    rearCameraActive = true;
                };
                
                rearVideo.src = '/video_feed/rear?' + Date.now();
            }, 500);
            
            // Show camera status panel
            document.getElementById('camera-status').style.display = 'block';
            document.getElementById('camera-btn').classList.add('active');
            
            // Check status after 3 seconds
            setTimeout(checkCameraStatus, 3000);
        }
        
        function stopCameras() {
            console.log('Stopping cameras...');
            document.getElementById('front-video').src = '';
            document.getElementById('front-video').style.display = 'none';
            document.getElementById('rear-video').src = '';
            document.getElementById('rear-video').style.display = 'none';
            document.getElementById('camera-status').style.display = 'none';
            document.getElementById('camera-btn').classList.remove('active');
            document.getElementById('camera-start-overlay').style.display = 'block';
            
            camerasActive = false;
            frontCameraActive = false;
            rearCameraActive = false;
        }
        
        function toggleCamera() {
            if (camerasActive) {
                stopCameras();
            } else {
                startCameras();
            }
        }
        
        function retryCameras() {
            document.getElementById('camera-error').style.display = 'none';
            startCameras();
        }
        
        function checkCameraStatus() {
            if (!frontCameraActive && !rearCameraActive) {
                document.getElementById('camera-error').style.display = 'block';
                document.getElementById('error-message').textContent = 
                    'No cameras detected. Check camera connections.';
            } else if (!frontCameraActive) {
                console.warn('Front camera not available, using rear only');
            } else if (!rearCameraActive) {
                console.warn('Rear camera not available, using front only');
            }
        }
        
        // Motor control
        const controlState = {
            mode: 'tank',
            left: 0,
            right: 0
        };

        let leftSlider;
        let rightSlider;
        let joystickControl;

        function clampPercent(value) {
            if (!Number.isFinite(value)) return 0;
            return Math.max(-100, Math.min(100, Math.round(value)));
        }

        function queueMotorCommand(force = false) {
            const now = performance.now();
            const timeSinceLast = now - lastMotorSend;
            const send = () => {
                const payload = { left: -controlState.left, right: -controlState.right };
                socket.volatile.emit('motor_control', payload);
                document.getElementById('status').textContent =
                    `Speed: L=${controlState.left}% R=${controlState.right}%`;
                lastMotorSend = performance.now();
                motorSendScheduled = false;
            };

            if (force) {
                send();
                return;
            }

            if (timeSinceLast >= MOTOR_COMMAND_INTERVAL) {
                send();
            } else if (!motorSendScheduled) {
                motorSendScheduled = true;
                setTimeout(() => send(), MOTOR_COMMAND_INTERVAL - timeSinceLast);
            }
        }

        function setControlSide(side, value, force = false) {
            controlState[side] = clampPercent(value);
            queueMotorCommand(force);
        }

        function setControlValues(left, right, force = false) {
            controlState.left = clampPercent(left);
            controlState.right = clampPercent(right);
            queueMotorCommand(force);
        }

        function onControlToggle(checked) {
            setControlMode(checked ? 'joystick' : 'tank');
        }

        function setControlMode(mode) {
            if (mode !== 'tank' && mode !== 'joystick') return;
            if (controlState.mode === mode) {
                const toggleInput = document.getElementById('control-toggle');
                if (toggleInput && toggleInput.checked !== (mode === 'joystick')) {
                    toggleInput.checked = mode === 'joystick';
                }
                return;
            }

            controlState.mode = mode;

            const tankControls = document.getElementById('tank-controls');
            const joystickControls = document.getElementById('joystick-control');
            const toggleInput = document.getElementById('control-toggle');

            if (toggleInput && toggleInput.checked !== (mode === 'joystick')) {
                toggleInput.checked = mode === 'joystick';
            }

            if (tankControls && joystickControls) {
                if (mode === 'joystick') {
                    tankControls.classList.add('hidden');
                    joystickControls.classList.remove('hidden');
                } else {
                    tankControls.classList.remove('hidden');
                    joystickControls.classList.add('hidden');
                }
            }

            if (joystickControl) joystickControl.cancel();
            if (leftSlider) leftSlider.cancel();
            if (rightSlider) rightSlider.cancel();

            setControlValues(0, 0, true);
        }

        class MotorSlider {
            constructor(element, side) {
                this.thumb = element;
                this.side = side;
                this.value = 0;
                this.pointerId = null;
                this.dragging = false;
                this.track = this.thumb.parentElement;
                this.track.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                this.thumb.addEventListener('pointerdown', (e) => this.startDrag(e));
                this.thumb.addEventListener('pointermove', (e) => this.onPointerMove(e));
                this.thumb.addEventListener('pointerup', (e) => this.endDrag(e));
                this.thumb.addEventListener('pointercancel', (e) => this.endDrag(e));
                this.resetThumb(false);
            }

            startDrag(e) {
                if (controlState.mode !== 'tank') return;
                e.preventDefault();
                this.dragging = true;
                this.pointerId = e.pointerId;
                this.thumb.setPointerCapture(this.pointerId);
                this.thumb.classList.add('active');
                this.thumb.style.transition = '';
                this.updateValueFromEvent(e);
            }

            onPointerMove(e) {
                if (!this.dragging || e.pointerId !== this.pointerId) return;
                this.updateValueFromEvent(e);
            }

            endDrag(e) {
                if (!this.dragging || (e && e.pointerId !== this.pointerId)) return;
                this.releasePointer();
                this.dragging = false;
                this.value = 0;
                this.resetThumb(true);
                setControlSide(this.side, this.value, true);
            }

            releasePointer() {
                if (this.pointerId !== null) {
                    try { this.thumb.releasePointerCapture(this.pointerId); } catch (err) {}
                }
                this.pointerId = null;
                this.thumb.classList.remove('active');
            }

            cancel() {
                this.releasePointer();
                this.dragging = false;
                this.value = 0;
                this.resetThumb(false);
            }

            updateValueFromEvent(e) {
                if (controlState.mode !== 'tank') return;
                const rect = this.track.getBoundingClientRect();
                const thumbHeight = this.thumb.offsetHeight;
                const range = Math.max(1, rect.height - thumbHeight);
                const y = e.clientY - rect.top - thumbHeight / 2;
                const clamped = Math.max(0, Math.min(range, y));
                this.thumb.style.top = `${clamped}px`;

                const normalized = 1 - (clamped / range);
                const symmetric = normalized * 2 - 1;
                const magnitude = Math.pow(Math.abs(symmetric), SPEED_CURVE_EXPONENT);
                const curved = symmetric >= 0 ? magnitude : -magnitude;
                let value = Math.round(curved * 100);
                if (Math.abs(value) < SPEED_DEAD_ZONE) {
                    value = 0;
                }
                this.value = Math.max(-100, Math.min(100, value));
                setControlSide(this.side, this.value);
            }

            resetThumb(animate = true) {
                const thumbHeight = this.thumb.offsetHeight;
                const range = this.track.offsetHeight - thumbHeight;
                const center = range / 2;
                this.thumb.classList.remove('active');
                if (animate) {
                    this.thumb.style.transition = 'top 0.12s ease-out';
                } else {
                    this.thumb.style.transition = '';
                }
                this.thumb.style.top = `${center}px`;
                if (animate) {
                    setTimeout(() => { this.thumb.style.transition = ''; }, 150);
                }
            }
        }

        class JoystickControl {
            constructor(baseElement, thumbElement) {
                this.base = baseElement;
                this.thumb = thumbElement;
                this.pointerId = null;
                this.active = false;

                this.base.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                this.base.addEventListener('pointerdown', (e) => this.start(e));
                this.base.addEventListener('pointermove', (e) => this.move(e));
                this.base.addEventListener('pointerup', (e) => this.end(e));
                this.base.addEventListener('pointercancel', (e) => this.end(e));
            }

            start(e) {
                if (controlState.mode !== 'joystick') return;
                e.preventDefault();
                this.active = true;
                this.pointerId = e.pointerId;
                this.base.setPointerCapture(this.pointerId);
                this.thumb.style.transition = 'none';
                this.base.classList.add('active');
                this.updateFromEvent(e);
            }

            move(e) {
                if (!this.active || e.pointerId !== this.pointerId) return;
                this.updateFromEvent(e);
            }

            end(e) {
                if (!this.active || (e && e.pointerId !== this.pointerId)) return;
                if (this.pointerId !== null) {
                    try { this.base.releasePointerCapture(this.pointerId); } catch (err) {}
                }
                this.pointerId = null;
                this.active = false;
                this.reset(true);
                setControlValues(0, 0, true);
            }

            cancel() {
                if (this.pointerId !== null) {
                    try { this.base.releasePointerCapture(this.pointerId); } catch (err) {}
                }
                this.pointerId = null;
                this.active = false;
                this.reset(false);
            }

            updateFromEvent(e) {
                if (controlState.mode !== 'joystick') return;
                const rect = this.base.getBoundingClientRect();
                const radius = rect.width / 2;
                if (radius <= 0) return;

                let offsetX = e.clientX - (rect.left + radius);
                let offsetY = e.clientY - (rect.top + radius);
                const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
                if (distance > radius) {
                    const scale = radius / distance;
                    offsetX *= scale;
                    offsetY *= scale;
                }

                this.thumb.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;

                const normalizedX = offsetX / radius;
                const normalizedY = -offsetY / radius;

                let forward = normalizedY;
                let turn = normalizedX;

                let left = forward + turn;
                let right = forward - turn;

                const maxMagnitude = Math.max(1, Math.max(Math.abs(left), Math.abs(right)));
                left /= maxMagnitude;
                right /= maxMagnitude;

                let leftCurved = Math.sign(left) * Math.pow(Math.abs(left), SPEED_CURVE_EXPONENT);
                let rightCurved = Math.sign(right) * Math.pow(Math.abs(right), SPEED_CURVE_EXPONENT);

                let leftPercent = Math.round(leftCurved * 100);
                let rightPercent = Math.round(rightCurved * 100);

                if (Math.abs(leftPercent) < SPEED_DEAD_ZONE) leftPercent = 0;
                if (Math.abs(rightPercent) < SPEED_DEAD_ZONE) rightPercent = 0;

                setControlValues(leftPercent, rightPercent);
            }

            reset(animate = true) {
                this.base.classList.remove('active');
                if (animate) {
                    this.thumb.style.transition = 'transform 0.12s ease-out';
                } else {
                    this.thumb.style.transition = '';
                }
                this.thumb.style.transform = 'translate(-50%, -50%)';
                if (animate) {
                    setTimeout(() => { this.thumb.style.transition = ''; }, 150);
                }
            }
        }

        leftSlider = new MotorSlider(document.getElementById('left-thumb'), 'left');
        rightSlider = new MotorSlider(document.getElementById('right-thumb'), 'right');
        joystickControl = new JoystickControl(
            document.getElementById('joystick-base'),
            document.getElementById('joystick-thumb')
        );

        function emergencyStop() {
            socket.emit('emergency_stop');
            if (leftSlider) leftSlider.cancel();
            if (rightSlider) rightSlider.cancel();
            if (joystickControl) joystickControl.cancel();
            setControlValues(0, 0, true);
            document.getElementById('status').textContent = 'STOPPED';
        }

        function shutdownCrawler() {
            if (!confirm('Shut down the crawler?\n\nAfter shutdown completes you must flip the power switch.')) {
                return;
            }

            fetch('/api/shutdown', { method: 'POST' })
                .then(res => {
                    if (!res.ok) throw new Error('Failed to request shutdown');
                    alert('Shutdown requested. Wait for the Pi to power down, then flip the main switch.');
                })
                .catch(err => {
                    console.error(err);
                    alert('Unable to request shutdown. Check connection and try again.');
                });
        }

        function changeStreamQuality(profile) {
            fetch('/api/camera/quality', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ profile })
            }).then(res => {
                if (!res.ok) throw new Error('Quality change failed');
            }).catch(err => {
                console.error(err);
                alert('Could not change camera quality.');
            });
        }

        function refreshStatus() {
            fetch('/api/status')
                .then(res => res.json())
                .then(data => {
                    if (data && data.cameras && data.cameras.profile) {
                        const select = document.getElementById('quality-select');
                        if (select && data.cameras.profile !== select.value) {
                            select.value = data.cameras.profile;
                        }
                    }
                })
                .catch(() => {});
        }

        setInterval(refreshStatus, 2000);
        refreshStatus();
    </script>
</body>
</html>
