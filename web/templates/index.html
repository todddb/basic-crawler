<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Crawler Control</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }
        
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0,0,0,0.8);
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 100;
            gap: 12px;
        }

        #header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #header-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn {
            background: #333;
            color: #fff;
            border: none;
            padding: 10px 15px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .btn:hover { background: #555; }
        .btn.active { background: #4CAF50; }
        .btn.emergency { background: #d32f2f; }
        .btn.shutdown { background: #f57c00; }

        #quality-select {
            background: #222;
            color: #fff;
            border: 1px solid #444;
            padding: 8px 10px;
            border-radius: 4px;
        }

        #video-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #111;
        }
        
        #camera-start-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 50;
        }
        
        #camera-start-overlay button {
            padding: 20px 40px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        #camera-start-overlay button:hover {
            background: #5CBF60;
        }
        
        #front-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none;
            transform: scaleY(-1);
        }
        
        #rear-video {
            position: absolute;
            top: 90px;
            right: 20px;
            width: 320px;
            height: 240px;
            border: 2px solid #444;
            border-radius: 10px;
            background: #222;
            display: none;
            object-fit: cover;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
        }

        .camera-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #f44336;
            display: none;
        }
        
        .control-slider {
            position: fixed;
            width: 60px;
            height: 400px;
            background: rgba(255,255,255,0.1);
            border-radius: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-slider.left { left: 20px; bottom: 100px; }
        .control-slider.right { right: 20px; bottom: 100px; }

        .slider-track {
            width: 40px;
            height: 375px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            position: relative;
        }

        .slider-thumb {
            width: 36px;
            height: 36px;
            background: #4CAF50;
            border-radius: 50%;
            position: absolute;
            left: 2px;
            top: 0;
            cursor: pointer;
            border: 2px solid #fff;
        }
        
        .control-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 12px;
        }
        
        #status {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 5px;
            font-size: 14px;
        }
        
        .camera-status {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-dot.active { background: #4CAF50; }
        .status-dot.inactive { background: #f44336; }
    </style>
</head>
<body>
    <div id="header">
        <div id="header-left">
            <h2>ü§ñ Crawler</h2>
            <span id="connection-status">Disconnected</span>
        </div>
        <div id="header-controls">
            <label for="quality-select" style="font-size: 12px;">Stream:</label>
            <select id="quality-select" onchange="changeStreamQuality(this.value)">
                <option value="balanced">Balanced</option>
                <option value="low">Low Lag</option>
                <option value="high">High Detail</option>
            </select>
            <button id="camera-btn" class="btn" onclick="toggleCamera()">üìπ Camera</button>
            <button class="btn emergency" onclick="emergencyStop()">üõë STOP</button>
            <button class="btn shutdown" onclick="shutdownCrawler()">‚èª Shutdown</button>
        </div>
    </div>
    
    <div id="video-container">
        <div id="camera-start-overlay">
            <button onclick="startCameras()">üìπ Start Cameras</button>
            <p style="margin-top: 20px; color: #999;">Click to start camera streams</p>
        </div>
        
        <div class="camera-error" id="camera-error">
            <h3>Camera Error</h3>
            <p id="error-message"></p>
            <button class="btn" onclick="retryCameras()">Retry</button>
        </div>
        
        <img id="front-video" alt="Front Camera">
        <img id="rear-video" alt="Rear Camera">
        
        <div class="camera-status" id="camera-status" style="display: none;">
            <div><span class="status-dot" id="front-status"></span>Front Camera</div>
            <div><span class="status-dot" id="rear-status"></span>Rear Camera</div>
        </div>
    </div>
    
    <div class="control-slider left">
        <div class="slider-track">
            <div class="slider-thumb" id="left-thumb"></div>
        </div>
        <div class="control-label">LEFT</div>
    </div>
    
    <div class="control-slider right">
        <div class="slider-track">
            <div class="slider-thumb" id="right-thumb"></div>
        </div>
        <div class="control-label">RIGHT</div>
    </div>
    
    <div id="status">Speed: L=0% R=0%</div>
    
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // WebSocket connection
        const socket = io();
        let camerasActive = false;
        let frontCameraActive = false;
        let rearCameraActive = false;
        let motorSendScheduled = false;
        let lastMotorSend = 0;
        const MOTOR_COMMAND_INTERVAL = 60; // ms
        const SPEED_CURVE_EXPONENT = 2.4;
        const SPEED_DEAD_ZONE = 8;

        socket.on('connect', () => {
            document.getElementById('connection-status').textContent = 'Connected';
            document.getElementById('connection-status').style.color = '#4CAF50';
        });
        
        socket.on('disconnect', () => {
            document.getElementById('connection-status').textContent = 'Disconnected';
            document.getElementById('connection-status').style.color = '#f44336';
        });
        
        // Camera management
        function startCameras() {
            console.log('Starting cameras...');
            document.getElementById('camera-start-overlay').style.display = 'none';
            document.getElementById('camera-error').style.display = 'none';
            
            // Start front camera
            const frontVideo = document.getElementById('front-video');
            frontVideo.onerror = function() {
                console.error('Front camera failed to load');
                document.getElementById('front-status').className = 'status-dot inactive';
                frontCameraActive = false;
                checkCameraStatus();
            };
            
            frontVideo.onload = function() {
                console.log('Front camera loaded');
                frontVideo.style.display = 'block';
                document.getElementById('front-status').className = 'status-dot active';
                frontCameraActive = true;
                camerasActive = true;
            };
            
            // Add timestamp to force reload
            frontVideo.src = '/video_feed/front?' + Date.now();
            
            // Start rear camera with delay
            setTimeout(() => {
                const rearVideo = document.getElementById('rear-video');
                rearVideo.onerror = function() {
                    console.error('Rear camera failed to load');
                    document.getElementById('rear-status').className = 'status-dot inactive';
                    rearCameraActive = false;
                };
                
                rearVideo.onload = function() {
                    console.log('Rear camera loaded');
                    rearVideo.style.display = 'block';
                    document.getElementById('rear-status').className = 'status-dot active';
                    rearCameraActive = true;
                };
                
                rearVideo.src = '/video_feed/rear?' + Date.now();
            }, 500);
            
            // Show camera status panel
            document.getElementById('camera-status').style.display = 'block';
            document.getElementById('camera-btn').classList.add('active');
            
            // Check status after 3 seconds
            setTimeout(checkCameraStatus, 3000);
        }
        
        function stopCameras() {
            console.log('Stopping cameras...');
            document.getElementById('front-video').src = '';
            document.getElementById('front-video').style.display = 'none';
            document.getElementById('rear-video').src = '';
            document.getElementById('rear-video').style.display = 'none';
            document.getElementById('camera-status').style.display = 'none';
            document.getElementById('camera-btn').classList.remove('active');
            document.getElementById('camera-start-overlay').style.display = 'block';
            
            camerasActive = false;
            frontCameraActive = false;
            rearCameraActive = false;
        }
        
        function toggleCamera() {
            if (camerasActive) {
                stopCameras();
            } else {
                startCameras();
            }
        }
        
        function retryCameras() {
            document.getElementById('camera-error').style.display = 'none';
            startCameras();
        }
        
        function checkCameraStatus() {
            if (!frontCameraActive && !rearCameraActive) {
                document.getElementById('camera-error').style.display = 'block';
                document.getElementById('error-message').textContent = 
                    'No cameras detected. Check camera connections.';
            } else if (!frontCameraActive) {
                console.warn('Front camera not available, using rear only');
            } else if (!rearCameraActive) {
                console.warn('Rear camera not available, using front only');
            }
        }
        
        // Motor control
        class MotorSlider {
            constructor(element, side) {
                this.thumb = element;
                this.side = side;
                this.value = 0;
                this.pointerId = null;
                this.dragging = false;
                this.track = this.thumb.parentElement;
                this.track.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                this.thumb.addEventListener('pointerdown', (e) => this.startDrag(e));
                this.thumb.addEventListener('pointermove', (e) => this.onPointerMove(e));
                this.thumb.addEventListener('pointerup', (e) => this.endDrag(e));
                this.thumb.addEventListener('pointercancel', (e) => this.endDrag(e));
                this.resetThumb(false);
            }

            startDrag(e) {
                e.preventDefault();
                this.dragging = true;
                this.pointerId = e.pointerId;
                this.thumb.setPointerCapture(this.pointerId);
                this.thumb.classList.add('active');
                this.updateValueFromEvent(e);
            }

            onPointerMove(e) {
                if (!this.dragging || e.pointerId !== this.pointerId) return;
                this.updateValueFromEvent(e);
            }

            endDrag(e) {
                if (!this.dragging || (e && e.pointerId !== this.pointerId)) return;

                if (this.pointerId !== null) {
                    try { this.thumb.releasePointerCapture(this.pointerId); } catch (err) {}
                }
                this.pointerId = null;
                this.dragging = false;
                this.value = 0;
                this.resetThumb(true);
                queueMotorCommand(true);
            }

            updateValueFromEvent(e) {
                const rect = this.track.getBoundingClientRect();
                const thumbHeight = this.thumb.offsetHeight;
                const range = Math.max(1, rect.height - thumbHeight);
                const y = e.clientY - rect.top - thumbHeight / 2;
                const clamped = Math.max(0, Math.min(range, y));
                this.thumb.style.top = `${clamped}px`;

                const normalized = 1 - (clamped / range);
                const symmetric = normalized * 2 - 1;
                const magnitude = Math.pow(Math.abs(symmetric), SPEED_CURVE_EXPONENT);
                const curved = symmetric >= 0 ? magnitude : -magnitude;
                let value = Math.round(curved * 100);
                if (Math.abs(value) < SPEED_DEAD_ZONE) {
                    value = 0;
                }
                this.value = Math.max(-100, Math.min(100, value));
                queueMotorCommand();
            }

            resetThumb(animate = true) {
                const thumbHeight = this.thumb.offsetHeight;
                const range = this.track.offsetHeight - thumbHeight;
                const center = range / 2;
                this.thumb.classList.remove('active');
                if (animate) {
                    this.thumb.style.transition = 'top 0.12s ease-out';
                }
                this.thumb.style.top = `${center}px`;
                if (animate) {
                    setTimeout(() => { this.thumb.style.transition = ''; }, 150);
                }
            }
        }

        const leftSlider = new MotorSlider(document.getElementById('left-thumb'), 'left');
        const rightSlider = new MotorSlider(document.getElementById('right-thumb'), 'right');

        function queueMotorCommand(force = false) {
            const now = performance.now();
            const timeSinceLast = now - lastMotorSend;
            const send = () => {
                const display = { left: leftSlider.value, right: rightSlider.value };
                const payload = { left: leftSlider.value, right: rightSlider.value };
                socket.volatile.emit('motor_control', payload);
                document.getElementById('status').textContent =
                    `Speed: L=${display.left}% R=${display.right}%`;
                lastMotorSend = performance.now();
                motorSendScheduled = false;
            };

            if (force) {
                send();
                return;
            }

            if (timeSinceLast >= MOTOR_COMMAND_INTERVAL) {
                send();
            } else if (!motorSendScheduled) {
                motorSendScheduled = true;
                setTimeout(() => send(), MOTOR_COMMAND_INTERVAL - timeSinceLast);
            }
        }
        
        function emergencyStop() {
            socket.emit('emergency_stop');
            leftSlider.value = 0;
            rightSlider.value = 0;
            leftSlider.resetThumb(false);
            rightSlider.resetThumb(false);
            document.getElementById('status').textContent = 'STOPPED';
        }

        function shutdownCrawler() {
            if (!confirm('Shut down the crawler?\n\nAfter shutdown completes you must flip the power switch.')) {
                return;
            }

            fetch('/api/shutdown', { method: 'POST' })
                .then(res => {
                    if (!res.ok) throw new Error('Failed to request shutdown');
                    alert('Shutdown requested. Wait for the Pi to power down, then flip the main switch.');
                })
                .catch(err => {
                    console.error(err);
                    alert('Unable to request shutdown. Check connection and try again.');
                });
        }

        function changeStreamQuality(profile) {
            fetch('/api/camera/quality', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ profile })
            }).then(res => {
                if (!res.ok) throw new Error('Quality change failed');
            }).catch(err => {
                console.error(err);
                alert('Could not change camera quality.');
            });
        }

        function refreshStatus() {
            fetch('/api/status')
                .then(res => res.json())
                .then(data => {
                    if (data && data.cameras && data.cameras.profile) {
                        const select = document.getElementById('quality-select');
                        if (select && data.cameras.profile !== select.value) {
                            select.value = data.cameras.profile;
                        }
                    }
                })
                .catch(() => {});
        }

        setInterval(refreshStatus, 2000);
        refreshStatus();
    </script>
</body>
</html>
