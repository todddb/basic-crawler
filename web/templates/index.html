<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Crawler Control</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }
        
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0,0,0,0.8);
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 100;
            gap: 12px;
        }

        #header-metrics {
            display: flex;
            align-items: center;
            gap: 16px;
            flex: 0 0 auto;
        }

        #header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #header-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #battery-widget {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 6px 12px;
            border-radius: 12px;
            min-width: 140px;
            transition: background 0.3s ease, border-color 0.3s ease;
        }

        #battery-widget[data-state="warning"] {
            background: rgba(255, 193, 7, 0.18);
            border-color: rgba(255, 193, 7, 0.38);
        }

        #battery-widget[data-state="critical"] {
            background: rgba(244, 67, 54, 0.2);
            border-color: rgba(244, 67, 54, 0.45);
        }

        #battery-widget[data-state="unknown"] {
            opacity: 0.65;
        }

        .battery-body {
            position: relative;
            width: 46px;
            height: 18px;
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 5px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.35);
        }

        .battery-cap {
            position: absolute;
            right: -6px;
            top: 4px;
            width: 5px;
            height: 8px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.6);
        }

        #battery-level {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 12%;
            background: #4CAF50;
            transition: width 0.3s ease, background 0.3s ease;
        }

        #battery-widget[data-state="warning"] #battery-level {
            background: #FFC107;
        }

        #battery-widget[data-state="critical"] #battery-level {
            background: #F44336;
        }

        #battery-widget[data-state="unknown"] #battery-level {
            background: #777;
        }

        .battery-text {
            display: flex;
            flex-direction: column;
            line-height: 1.1;
        }

        .battery-text span {
            font-size: 14px;
            font-weight: 600;
        }

        .battery-text small {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
        }

        #settings-btn {
            width: 40px;
            height: 40px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
        }

        #settings-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }

        .toggle-container span {
            color: #bbb;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: 0.2s;
            border-radius: 12px;
        }

        .toggle-slider::before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: #fff;
            transition: 0.2s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #4CAF50;
        }

        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(22px);
        }

        .btn {
            background: #333;
            color: #fff;
            border: none;
            padding: 10px 15px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
        }

        .btn.small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }

        .btn:hover { background: #555; }
        .btn.active { background: #4CAF50; }
        .btn.emergency { background: #d32f2f; }
        .btn.shutdown { background: #f57c00; }

        #quality-select {
            background: #222;
            color: #fff;
            border: 1px solid #444;
            padding: 8px 10px;
            border-radius: 4px;
        }

        #settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        #settings-overlay.hidden {
            display: none;
        }

        #settings-panel {
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            width: min(900px, 94vw);
            max-height: 92vh;
            padding: 24px 28px;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.45);
            display: flex;
            flex-direction: column;
            gap: 18px;
            overflow-y: auto;
        }

        .settings-body {
            display: flex;
            align-items: stretch;
            justify-content: space-between;
            gap: 24px;
            flex-wrap: wrap;
        }

        .settings-column {
            flex: 1 1 320px;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .settings-column-right {
            flex: 1.1 1 380px;
        }

        .wifi-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .wifi-section .settings-option-group {
            align-items: stretch;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .settings-header h3 {
            font-size: 20px;
            font-weight: 600;
        }

        #settings-close {
            background: transparent;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
        }

        #settings-close:hover {
            color: #4CAF50;
        }

        .settings-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .settings-section label {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            color: rgba(255, 255, 255, 0.7);
        }

        .settings-option-group {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .settings-option-group.column {
            flex-direction: column;
            align-items: stretch;
        }

        .radio-option {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.06);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid transparent;
        }

        .radio-option input {
            accent-color: #4CAF50;
        }

        .radio-option.active {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.18);
        }

        .settings-section input[type="text"],
        .settings-section input[type="password"] {
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 10px;
            color: #fff;
            width: 100%;
        }

        .settings-section input[type="text"]::placeholder,
        .settings-section input[type="password"]::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .settings-section input[type="text"]:focus,
        .settings-section input[type="password"]:focus {
            outline: 2px solid rgba(76, 175, 80, 0.45);
            border-color: rgba(76, 175, 80, 0.65);
        }

        .wifi-selected-display {
            width: 100%;
            min-height: 38px;
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.35);
            color: #fff;
            display: flex;
            align-items: center;
        }

        .wifi-selected-display.placeholder {
            color: rgba(255, 255, 255, 0.55);
            font-style: italic;
        }

        .wifi-status-line {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .wifi-current-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .wifi-current-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.55);
        }

        .wifi-current-value {
            font-size: 14px;
            font-weight: 600;
        }

        .wifi-network-list {
            width: 100%;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(0, 0, 0, 0.28);
            max-height: clamp(240px, 45vh, 360px);
            overflow-y: auto;
            flex: 1;
        }

        .wifi-network-empty {
            padding: 14px;
            text-align: center;
            color: rgba(255, 255, 255, 0.55);
            font-size: 13px;
        }

        .wifi-network-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px 14px;
            border: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            background: transparent;
            color: inherit;
            cursor: pointer;
            text-align: left;
        }

        .wifi-network-item:last-child {
            border-bottom: none;
        }

        .wifi-network-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .wifi-network-item.active {
            background: rgba(76, 175, 80, 0.16);
            border-left: 3px solid #4CAF50;
        }

        .wifi-network-item.selected {
            box-shadow: inset 0 0 0 2px rgba(80, 160, 255, 0.5);
            background: rgba(80, 160, 255, 0.12);
        }

        .wifi-network-label {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .wifi-network-name {
            font-weight: 600;
            font-size: 14px;
        }

        .wifi-network-name.hidden-ssid {
            font-style: italic;
            color: rgba(255, 255, 255, 0.7);
        }

        .wifi-network-meta {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.55);
        }

        .wifi-network-signal {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
            font-size: 12px;
        }

        .wifi-signal-bars {
            display: flex;
            align-items: flex-end;
            justify-content: flex-end;
            gap: 3px;
            height: 18px;
        }

        .wifi-signal-bar {
            width: 5px;
            border-radius: 2px 2px 0 0;
            background: rgba(255, 255, 255, 0.14);
            transition: background 0.2s ease, opacity 0.2s ease;
        }

        .wifi-signal-bar.active {
            background: linear-gradient(180deg, rgba(160, 255, 173, 0.95), rgba(76, 175, 80, 0.95));
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.35);
        }

        .wifi-network-item:hover .wifi-signal-bar.active {
            background: linear-gradient(180deg, rgba(184, 255, 193, 1), rgba(88, 200, 94, 1));
        }

        .wifi-signal-percent {
            color: rgba(255, 255, 255, 0.7);
        }

        .wifi-message {
            min-height: 18px;
            color: rgba(255, 255, 255, 0.75);
        }

        .wifi-message.error {
            color: #ff8a80;
        }

        .wifi-message.success {
            color: #b7ffb4;
        }

        #wifi-psk-group.disabled input {
            opacity: 0.5;
        }

        #wifi-psk-group.disabled label::after {
            content: " (not required)";
            font-size: 12px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.6);
        }

        .wifi-auth-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .wifi-network-list.loading {
            opacity: 0.65;
        }

        .wifi-network-list::-webkit-scrollbar {
            width: 6px;
        }

        .wifi-network-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .wifi-network-list::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.35);
        }

        #video-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #111;
        }
        
        #camera-start-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 50;
        }
        
        #camera-start-overlay button {
            padding: 20px 40px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        #camera-start-overlay button:hover {
            background: #5CBF60;
        }
        
        #front-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none;
            transform: scaleY(-1);
        }
        
        #rear-video {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            height: 240px;
            border: 2px solid #444;
            border-radius: 10px;
            background: #222;
            display: none;
            object-fit: cover;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
        }

        .camera-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #f44336;
            display: none;
        }
        
        .hidden {
            display: none !important;
        }

        .control-slider {
            position: fixed;
            width: 60px;
            height: 400px;
            background: rgba(255,255,255,0.1);
            border-radius: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-slider.left { left: 20px; bottom: 100px; }
        .control-slider.right { right: 20px; bottom: 100px; }

        #joystick-control {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 14px;
        }

        #joystick-base {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: rgba(255,255,255,0.08);
            border: 2px solid rgba(255,255,255,0.18);
            position: relative;
            touch-action: none;
            box-shadow: inset 0 10px 25px rgba(0,0,0,0.35);
        }

        #joystick-base.active {
            background: rgba(76,175,80,0.18);
            border-color: rgba(76,175,80,0.45);
        }

        #joystick-thumb {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #4CAF50;
            border: 3px solid #fff;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 12px 25px rgba(0,0,0,0.4);
            transition: transform 0.12s ease-out;
        }

        .joystick-label {
            font-size: 12px;
            letter-spacing: 2px;
            color: rgba(255,255,255,0.7);
        }

        .slider-track {
            width: 40px;
            height: 375px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            position: relative;
        }

        .slider-thumb {
            width: 36px;
            height: 36px;
            background: #4CAF50;
            border-radius: 50%;
            position: absolute;
            left: 2px;
            top: 0;
            cursor: pointer;
            border: 2px solid #fff;
        }
        
        .control-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 12px;
        }
        
        #status {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 5px;
            font-size: 14px;
        }

        #odometry-overlay {
            position: fixed;
            bottom: 20px;
            right: 110px;
            width: 240px;
            padding: 14px 16px;
            background: rgba(0, 0, 0, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
            z-index: 85;
            backdrop-filter: blur(6px);
        }

        #odometry-canvas {
            width: 100%;
            height: 200px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
        }

        .odometry-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .odometry-footer > div {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .odometry-actions {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: flex-end;
        }

        .odometry-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.6);
        }

        #odometry-distance {
            font-size: 16px;
            font-weight: 600;
        }

        @media (max-width: 1024px) {
            #settings-panel {
                width: min(760px, 94vw);
            }
        }

        @media (max-width: 840px) {
            #settings-panel {
                width: min(520px, 94vw);
                padding: 22px 24px;
            }

            .settings-body {
                flex-direction: column;
                gap: 20px;
            }

            .settings-column-right {
                flex: 1;
            }
        }

        @media (max-width: 900px) {
            #odometry-overlay {
                right: 20px;
            }
        }

        @media (max-width: 640px) {
            #header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            #header-metrics {
                width: 100%;
                justify-content: space-between;
            }

            #header-controls {
                width: 100%;
                justify-content: flex-start;
                flex-wrap: wrap;
            }

            #odometry-overlay {
                position: static;
                width: auto;
                margin: 12px 20px 0;
            }
        }
        
        .camera-status {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-dot.active { background: #4CAF50; }
        .status-dot.inactive { background: #f44336; }
    </style>
</head>
<body>
    <div id="header">
        <div id="header-left">
            <h2>ü§ñ Crawler</h2>
            <span id="connection-status">Disconnected</span>
        </div>
        <div id="header-metrics">
            <div id="battery-widget" data-state="unknown" title="Battery status">
                <div class="battery-body">
                    <div id="battery-level"></div>
                    <div class="battery-cap"></div>
                </div>
                <div class="battery-text">
                    <span id="battery-voltage">--.- V</span>
                    <small id="battery-percent">--%</small>
                </div>
            </div>
        </div>
        <div id="header-controls">
            <button id="settings-btn" class="btn" onclick="toggleSettings()" title="Settings">‚öôÔ∏è</button>
            <button id="camera-btn" class="btn" onclick="toggleCamera()">üìπ Camera</button>
            <button class="btn emergency" onclick="emergencyStop()">üõë STOP</button>
            <button class="btn shutdown" onclick="shutdownCrawler()">‚èª Shutdown</button>
        </div>
    </div>
    
    <div id="video-container">
        <div id="camera-start-overlay">
            <button onclick="startCameras()">üìπ Start Cameras</button>
            <p style="margin-top: 20px; color: #999;">Click to start camera streams</p>
        </div>
        
        <div class="camera-error" id="camera-error">
            <h3>Camera Error</h3>
            <p id="error-message"></p>
            <button class="btn" onclick="retryCameras()">Retry</button>
        </div>
        
        <img id="front-video" alt="Front Camera">
        <img id="rear-video" alt="Rear Camera">
        
        <div class="camera-status" id="camera-status" style="display: none;">
            <div><span class="status-dot" id="front-status"></span>Front Camera</div>
            <div><span class="status-dot" id="rear-status"></span>Rear Camera</div>
        </div>
    </div>
    
    <div id="tank-controls">
        <div class="control-slider left">
            <div class="slider-track">
                <div class="slider-thumb" id="left-thumb"></div>
            </div>
            <div class="control-label">LEFT</div>
        </div>

        <div class="control-slider right">
            <div class="slider-track">
                <div class="slider-thumb" id="right-thumb"></div>
            </div>
            <div class="control-label">RIGHT</div>
        </div>
    </div>

    <div id="joystick-control" class="hidden">
        <div id="joystick-base">
            <div id="joystick-thumb"></div>
        </div>
        <div class="joystick-label">JOYSTICK</div>
    </div>

    <div id="status">Speed: L=0% R=0%</div>

    <div id="odometry-overlay">
        <canvas id="odometry-canvas" width="220" height="220"></canvas>
        <div class="odometry-footer">
            <div>
                <div class="odometry-label">Distance</div>
                <div id="odometry-distance">0.0 ft</div>
            </div>
            <div class="odometry-actions">
                <button id="odometry-reset" class="btn small" type="button">Reset</button>
                <button id="odometry-return" class="btn small" type="button" disabled>
                    Return to start
                </button>
            </div>
        </div>
    </div>

    <div id="settings-overlay" class="hidden">
        <div id="settings-panel">
            <div class="settings-header">
                <h3>Settings</h3>
                <button id="settings-close" onclick="toggleSettings()" aria-label="Close settings">‚úï</button>
            </div>

            <div class="settings-body">
                <div class="settings-column settings-column-left">
                    <div class="settings-section">
                        <label for="quality-select">Video Quality</label>
                        <select id="quality-select" onchange="changeStreamQuality(this.value)">
                            <option value="balanced">Balanced</option>
                            <option value="low" selected>Low Lag</option>
                            <option value="high">High Detail</option>
                        </select>
                    </div>

                    <div class="settings-section">
                        <label>Control Style</label>
                        <div class="settings-option-group">
                            <div class="toggle-container" title="Toggle control scheme">
                                <span>Tank</span>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="control-toggle" checked onchange="onControlToggle(this.checked)">
                                    <span class="toggle-slider"></span>
                                </label>
                                <span>Joystick</span>
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <label>Input Device</label>
                        <div class="settings-option-group" id="input-method-options">
                            <label class="radio-option active">
                                <input type="radio" name="input-method" value="onscreen" checked onchange="onInputMethodChange(this.value)">
                                <span>On-Screen Controls</span>
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="input-method" value="keyboard" onchange="onInputMethodChange(this.value)">
                                <span>Keyboard</span>
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="input-method" value="xbox" onchange="onInputMethodChange(this.value)">
                                <span>Xbox Controller</span>
                            </label>
                        </div>
                        <small id="gamepad-status" style="color: rgba(255,255,255,0.6);">No gamepad detected.</small>
                    </div>
                </div>

                <div class="settings-column settings-column-right">
                    <div class="settings-section wifi-section">
                        <label>Wi-Fi</label>
                        <div class="wifi-status-line">
                            <div class="wifi-current-details">
                                <div class="wifi-current-label">Current Network</div>
                                <div id="wifi-current-network" class="wifi-current-value">Scanning‚Ä¶</div>
                            </div>
                            <button id="wifi-refresh" class="btn small" type="button">Refresh</button>
                        </div>
                        <div id="wifi-network-list" class="wifi-network-list">
                            <div class="wifi-network-empty">Scanning for networks‚Ä¶</div>
                        </div>
                        <div class="settings-option-group column">
                            <label for="wifi-selected-ssid">Selected Network</label>
                            <div id="wifi-selected-ssid" class="wifi-selected-display placeholder" aria-live="polite">Select a network</div>
                        </div>
                        <div class="settings-option-group column">
                            <label>Authentication</label>
                            <div id="wifi-auth-options" class="wifi-auth-options">
                                <label class="radio-option active">
                                    <input type="radio" name="wifi-auth-type" value="psk" checked>
                                    <span>Passphrase</span>
                                </label>
                                <label class="radio-option">
                                    <input type="radio" name="wifi-auth-type" value="enterprise">
                                    <span>Enterprise</span>
                                </label>
                            </div>
                        </div>
                        <div id="wifi-psk-group" class="settings-option-group column">
                            <label for="wifi-psk">Passphrase</label>
                            <input type="password" id="wifi-psk" placeholder="Network password">
                        </div>
                        <div id="wifi-enterprise-fields" class="settings-option-group column hidden">
                            <label for="wifi-username">Username</label>
                            <input type="text" id="wifi-username" placeholder="Identity">
                            <label for="wifi-password">Password</label>
                            <input type="password" id="wifi-password" placeholder="Password">
                        </div>
                        <div class="settings-option-group">
                            <button id="wifi-connect-btn" class="btn" type="button" disabled>Connect</button>
                        </div>
                        <div class="settings-option-group column">
                            <small id="wifi-message" class="wifi-message"></small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // WebSocket connection
        const socket = io();
        let camerasActive = false;
        let frontCameraActive = false;
        let rearCameraActive = false;
        let cameraProfileInitialized = false;
        let motorSendScheduled = false;
        let lastMotorSend = 0;
        const MOTOR_COMMAND_INTERVAL = 60; // ms
        const SPEED_CURVE_EXPONENT = 2.4;
        const SPEED_DEAD_ZONE = 8;
        const GAMEPAD_DEAD_ZONE = 0.18;
        const JOYSTICK_TURN_SENSITIVITY = 0.65;

        const telemetryState = {
            path: [{ x: 0, y: 0 }],
            sequence: 0,
            totalDistance: 0,
            resetPending: false,
            returnAvailable: false,
            returnInProgress: false,
        };

        const odometryCanvas = document.getElementById('odometry-canvas');
        const odometryCtx = odometryCanvas ? odometryCanvas.getContext('2d') : null;

        const odometryReturnButton = document.getElementById('odometry-return');
        const settingsPanel = document.getElementById('settings-panel');
        const RETURN_BUTTON_LABEL = 'Return to start';
        if (odometryReturnButton) {
            odometryReturnButton.textContent = RETURN_BUTTON_LABEL;
            odometryReturnButton.dataset.defaultLabel = RETURN_BUTTON_LABEL;
            odometryReturnButton.disabled = true;
        }

        if (settingsPanel) {
            ['mousedown', 'touchstart', 'click'].forEach((eventName) => {
                settingsPanel.addEventListener(eventName, (event) => {
                    event.stopPropagation();
                }, { capture: true });
            });
        }

        const inputState = {
            method: 'onscreen',
            gamepadIndex: null,
            pollHandle: null,
            lastLeft: 0,
            lastRight: 0,
            gamepadConnected: false,
            gamepadName: ''
        };

        const keyboardState = {
            keys: new Set(),
            lastLeft: 0,
            lastRight: 0
        };

        const KEYBOARD_CONTROL_CODES = new Set([
            'KeyW', 'KeyS', 'ArrowUp', 'ArrowDown',
            'KeyA', 'KeyD', 'ArrowLeft', 'ArrowRight'
        ]);

        let settingsVisible = false;

        const wifiState = {
            networks: [],
            active: null,
            selectedNetwork: null,
            selectedIdentifier: '',
            authType: 'psk',
            requiresPassphrase: true,
            loading: false,
            connecting: false,
            lastScan: 0,
        };

        let wifiInitialized = false;

        function getWifiIdentifier(network) {
            if (!network) return '';
            if (network.bssid) return String(network.bssid);
            if (network.ssid) return String(network.ssid);
            return '';
        }

        function setWifiMessage(text, type = 'info') {
            const messageEl = document.getElementById('wifi-message');
            if (!messageEl) return;
            messageEl.textContent = text || '';
            messageEl.classList.remove('error', 'success');
            if (type === 'error') {
                messageEl.classList.add('error');
            } else if (type === 'success') {
                messageEl.classList.add('success');
            }
        }

        function clearWifiMessage() {
            setWifiMessage('');
        }

        const WIFI_SIGNAL_BAR_HEIGHTS = [6, 10, 14, 18];

        function getWifiSignalLevel(signal) {
            if (!Number.isFinite(signal)) return 0;
            const value = Math.max(0, Math.min(100, Number(signal)));
            if (value >= 80) return 4;
            if (value >= 60) return 3;
            if (value >= 40) return 2;
            if (value >= 20) return 1;
            return 0;
        }

        function createWifiSignalBars(signal) {
            const container = document.createElement('div');
            container.className = 'wifi-signal-bars';
            container.setAttribute('aria-hidden', 'true');

            const level = getWifiSignalLevel(signal);
            WIFI_SIGNAL_BAR_HEIGHTS.forEach((height, index) => {
                const bar = document.createElement('span');
                bar.className = 'wifi-signal-bar';
                bar.style.height = `${height}px`;
                if (index < level) {
                    bar.classList.add('active');
                }
                container.appendChild(bar);
            });

            return container;
        }

        function formatWifiSignalPercent(signal) {
            if (!Number.isFinite(signal)) return '‚Äî';
            const value = Math.max(0, Math.min(100, Number(signal)));
            return `${Math.round(value)}%`;
        }

        function initializeWifiSettings() {
            if (wifiInitialized) return;
            wifiInitialized = true;

            const refreshButton = document.getElementById('wifi-refresh');
            if (refreshButton) {
                refreshButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    refreshWifiNetworks(true);
                });
            }

            const connectButton = document.getElementById('wifi-connect-btn');
            if (connectButton) {
                connectButton.addEventListener('click', onWifiConnectClick);
            }

            const authRadios = document.querySelectorAll('input[name="wifi-auth-type"]');
            authRadios.forEach((radio) => {
                radio.addEventListener('change', () => {
                    if (radio.checked) {
                        setWifiAuthType(radio.value);
                    }
                });
                if (radio.checked) {
                    wifiState.authType = radio.value === 'enterprise' ? 'enterprise' : 'psk';
                }
            });

            ['wifi-psk', 'wifi-username', 'wifi-password'].forEach((id) => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('input', () => {
                        updateWifiConnectAvailability();
                        clearWifiMessage();
                    });
                }
            });

            updateWifiAuthUI();
            updateWifiConnectAvailability();
        }

        async function refreshWifiNetworks(force = false, options = {}) {
            const { preserveMessage = false } = options || {};
            if (wifiState.loading) return;
            wifiState.loading = true;

            const listEl = document.getElementById('wifi-network-list');
            if (listEl) {
                listEl.classList.add('loading');
                if (force || !wifiState.networks.length) {
                    listEl.innerHTML = '<div class="wifi-network-empty">Scanning for networks‚Ä¶</div>';
                }
            }

            if (!preserveMessage) {
                setWifiMessage('Scanning for networks‚Ä¶');
            }

            try {
                const response = await fetch('/api/wifi/networks');
                if (!response.ok) {
                    throw new Error(`Request failed (${response.status})`);
                }
                const data = await response.json();
                if (!data || !data.success) {
                    throw new Error((data && data.error) || 'Unable to scan networks');
                }

                const networks = Array.isArray(data.networks) ? data.networks : [];
                wifiState.networks = networks;
                wifiState.active = data.active || null;
                wifiState.lastScan = Date.now();

                const previousId = wifiState.selectedIdentifier || getWifiIdentifier(wifiState.selectedNetwork);
                const activeId = getWifiIdentifier(wifiState.active);

                let matched = null;
                if (previousId) {
                    matched = networks.find((network) => getWifiIdentifier(network) === previousId) || null;
                }

                if (!matched && activeId) {
                    matched = networks.find((network) => getWifiIdentifier(network) === activeId) || wifiState.active;
                }

                wifiState.selectedNetwork = matched;
                wifiState.selectedIdentifier = getWifiIdentifier(matched) || '';

                renderWifiNetworks();
                updateWifiStatusDisplay();
                updateWifiSelectionUI();

                if (!preserveMessage) {
                    clearWifiMessage();
                }
            } catch (error) {
                console.error('Failed to refresh Wi-Fi networks', error);
                setWifiMessage(error.message || 'Unable to scan networks.', 'error');
                if (listEl) {
                    listEl.innerHTML = '<div class="wifi-network-empty">Unable to load networks</div>';
                }
            } finally {
                wifiState.loading = false;
                if (listEl) {
                    listEl.classList.remove('loading');
                }
                updateWifiConnectAvailability();
            }
        }

        function renderWifiNetworks() {
            const listEl = document.getElementById('wifi-network-list');
            if (!listEl) return;

            listEl.innerHTML = '';
            if (!wifiState.networks || wifiState.networks.length === 0) {
                listEl.innerHTML = '<div class="wifi-network-empty">No networks found</div>';
                return;
            }

            const selectedId = wifiState.selectedIdentifier;

            wifiState.networks.forEach((network) => {
                if (!network) return;
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'wifi-network-item';

                const identifier = getWifiIdentifier(network);
                if (network.active) {
                    button.classList.add('active');
                }
                if (selectedId && identifier === selectedId) {
                    button.classList.add('selected');
                }

                const label = document.createElement('div');
                label.className = 'wifi-network-label';

                const name = document.createElement('div');
                name.className = 'wifi-network-name';
                name.textContent = network.ssid || 'Hidden network';
                if (!network.ssid) {
                    name.classList.add('hidden-ssid');
                }

                const meta = document.createElement('div');
                meta.className = 'wifi-network-meta';
                meta.textContent = network.security || 'Open';

                label.appendChild(name);
                label.appendChild(meta);

                const signal = document.createElement('div');
                signal.className = 'wifi-network-signal';

                const bars = createWifiSignalBars(network.signal);

                const percent = document.createElement('div');
                percent.className = 'wifi-signal-percent';
                percent.textContent = formatWifiSignalPercent(network.signal);

                signal.appendChild(bars);
                signal.appendChild(percent);

                button.appendChild(label);
                button.appendChild(signal);

                button.addEventListener('click', (event) => {
                    event.stopPropagation();
                    selectWifiNetwork(network);
                });

                listEl.appendChild(button);
            });
        }

        function updateWifiStatusDisplay() {
            const currentEl = document.getElementById('wifi-current-network');
            if (!currentEl) return;

            const active = wifiState.active || (wifiState.networks || []).find((network) => network && network.active);
            if (active && (active.ssid || active.bssid)) {
                const name = active.ssid || active.bssid;
                const percent = formatWifiSignalPercent(active.signal);
                currentEl.textContent = percent === '‚Äî' ? name : `${name} (${percent})`;
            } else {
                currentEl.textContent = 'Not connected';
            }
        }

        function selectWifiNetwork(network) {
            if (!network) return;
            wifiState.selectedNetwork = network;
            wifiState.selectedIdentifier = getWifiIdentifier(network);
            if (wifiState.authType === 'enterprise' && !network.supports_enterprise) {
                wifiState.authType = 'psk';
            }
            clearWifiMessage();
            updateWifiSelectionUI();
            renderWifiNetworks();
        }

        function setWifiAuthType(value) {
            wifiState.authType = value === 'enterprise' ? 'enterprise' : 'psk';
            updateWifiAuthUI();
            updateWifiConnectAvailability();
        }

        function updateWifiSelectionUI() {
            const selected = wifiState.selectedNetwork;
            const display = document.getElementById('wifi-selected-ssid');
            if (display) {
                const name = selected && (selected.ssid || selected.bssid) ? (selected.ssid || selected.bssid) : '';
                if (name) {
                    display.textContent = name;
                    display.classList.remove('placeholder');
                } else {
                    display.textContent = 'Select a network';
                    display.classList.add('placeholder');
                }
            }

            wifiState.requiresPassphrase = selected ? selected.requires_passphrase !== false : true;

            if (selected && wifiState.authType === 'enterprise' && !selected.supports_enterprise) {
                wifiState.authType = 'psk';
            }

            const pskInput = document.getElementById('wifi-psk');
            if (pskInput && wifiState.requiresPassphrase === false) {
                pskInput.value = '';
            }

            updateWifiAuthUI();
            updateWifiConnectAvailability();
        }

        function updateWifiAuthUI() {
            const options = document.querySelectorAll('#wifi-auth-options .radio-option');
            options.forEach((option) => {
                const input = option.querySelector('input[type="radio"]');
                if (!input) return;
                const active = input.value === wifiState.authType;
                option.classList.toggle('active', active);
                if (input.checked !== active) {
                    input.checked = active;
                }
            });

            const pskGroup = document.getElementById('wifi-psk-group');
            const pskInput = document.getElementById('wifi-psk');
            const enterpriseGroup = document.getElementById('wifi-enterprise-fields');

            if (pskGroup) {
                const showPsk = wifiState.authType === 'psk';
                pskGroup.classList.toggle('hidden', !showPsk);
                pskGroup.classList.toggle('disabled', wifiState.requiresPassphrase === false);
            }

            if (pskInput) {
                const disablePsk = wifiState.authType !== 'psk' || wifiState.requiresPassphrase === false;
                pskInput.disabled = disablePsk;
                if (disablePsk) {
                    pskInput.value = '';
                }
            }

            if (enterpriseGroup) {
                enterpriseGroup.classList.toggle('hidden', wifiState.authType !== 'enterprise');
            }
        }

        function updateWifiConnectAvailability() {
            const button = document.getElementById('wifi-connect-btn');
            if (!button) return;

            const selected = wifiState.selectedNetwork;
            const hasSsid = Boolean(selected && selected.ssid);
            let ready = hasSsid;

            if (wifiState.authType === 'enterprise') {
                const usernameInput = document.getElementById('wifi-username');
                const passwordInput = document.getElementById('wifi-password');
                ready = ready && Boolean(usernameInput && usernameInput.value.trim()) && Boolean(passwordInput && passwordInput.value);
            } else if (wifiState.requiresPassphrase) {
                const pskInput = document.getElementById('wifi-psk');
                ready = ready && Boolean(pskInput && pskInput.value);
            }

            if (wifiState.connecting || wifiState.loading) {
                ready = false;
            }

            button.disabled = !ready;
        }

        async function onWifiConnectClick(event) {
            if (event) {
                event.stopPropagation();
            }
            if (wifiState.connecting) return;
            const button = document.getElementById('wifi-connect-btn');
            if (!button || button.disabled) {
                return;
            }

            const selected = wifiState.selectedNetwork;
            if (!selected || !selected.ssid) {
                setWifiMessage('Select a visible network to connect.', 'error');
                return;
            }

            const payload = { ssid: selected.ssid };
            if (selected.bssid) {
                payload.bssid = selected.bssid;
            }

            if (wifiState.authType === 'enterprise') {
                const usernameInput = document.getElementById('wifi-username');
                const passwordInput = document.getElementById('wifi-password');
                const username = usernameInput ? usernameInput.value.trim() : '';
                const password = passwordInput ? passwordInput.value : '';
                if (!username || !password) {
                    setWifiMessage('Enter both username and password.', 'error');
                    return;
                }
                payload.username = username;
                payload.password = password;
            } else if (wifiState.requiresPassphrase) {
                const pskInput = document.getElementById('wifi-psk');
                const psk = pskInput ? pskInput.value : '';
                if (!psk) {
                    setWifiMessage('Enter the network passphrase.', 'error');
                    return;
                }
                payload.psk = psk;
            }

            wifiState.connecting = true;
            updateWifiConnectAvailability();
            const originalLabel = button.textContent;
            button.textContent = 'Connecting‚Ä¶';
            setWifiMessage('Connecting‚Ä¶');

            try {
                const response = await fetch('/api/wifi/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data.success) {
                    throw new Error((data && data.error) || `Request failed (${response.status})`);
                }

                setWifiMessage(data.message || 'Connected successfully.', 'success');
                await refreshWifiNetworks(true, { preserveMessage: true });
                const pskInput = document.getElementById('wifi-psk');
                if (pskInput) {
                    pskInput.value = '';
                }
            } catch (error) {
                console.error('Failed to connect to Wi-Fi', error);
                setWifiMessage(error.message || 'Unable to connect to Wi-Fi.', 'error');
            } finally {
                wifiState.connecting = false;
                button.textContent = originalLabel;
                updateWifiConnectAvailability();
            }
        }


        function estimatePercentFromCellVoltage(cellVoltage) {
            if (!Number.isFinite(cellVoltage)) return null;
            const minCell = 3.2;
            const maxCell = 4.2;
            const span = maxCell - minCell;
            if (span <= 0) return null;
            const normalized = (cellVoltage - minCell) / span;
            return Math.max(0, Math.min(100, normalized * 100));
        }

        function updateBatteryIndicator(battery) {
            const widget = document.getElementById('battery-widget');
            const voltageEl = document.getElementById('battery-voltage');
            const percentEl = document.getElementById('battery-percent');
            const levelEl = document.getElementById('battery-level');

            if (!widget || !voltageEl || !percentEl || !levelEl) {
                return;
            }

            if (!battery || !Number.isFinite(battery.voltage)) {
                widget.dataset.state = 'unknown';
                voltageEl.textContent = '--.- V';
                percentEl.textContent = '--%';
                levelEl.style.width = '8%';
                return;
            }

            widget.dataset.state = battery.state || 'normal';
            voltageEl.textContent = `${battery.voltage.toFixed(1)} V`;

            let percentValue = Number.isFinite(battery.percent) ? battery.percent : null;
            if (percentValue === null && Number.isFinite(battery.cell_voltage)) {
                percentValue = estimatePercentFromCellVoltage(battery.cell_voltage);
            }

            if (percentValue !== null && Number.isFinite(percentValue)) {
                const clamped = Math.max(0, Math.min(100, percentValue));
                percentEl.textContent = `${Math.round(clamped)}%`;
                levelEl.style.width = `${Math.max(6, Math.round(clamped))}%`;
            } else if (Number.isFinite(battery.cell_voltage)) {
                percentEl.textContent = `${battery.cell_voltage.toFixed(2)} V/cell`;
                levelEl.style.width = '100%';
            } else {
                percentEl.textContent = '--%';
                levelEl.style.width = '12%';
            }
        }

        function updateDistanceLabel(distance) {
            const distanceEl = document.getElementById('odometry-distance');
            if (!distanceEl) return;
            if (Number.isFinite(distance)) {
                distanceEl.textContent = `${distance.toFixed(1)} ft`;
            } else {
                distanceEl.textContent = '--';
            }
        }

        function updateReturnButtonFromOdometry(odometry) {
            if (!odometryReturnButton) return;
            const inProgress = Boolean(odometry && odometry.return_in_progress);
            const available = Boolean(odometry && odometry.return_available);
            const defaultLabel = odometryReturnButton.dataset.defaultLabel || RETURN_BUTTON_LABEL;

            if (inProgress) {
                odometryReturnButton.disabled = true;
                odometryReturnButton.textContent = 'Returning...';
                return;
            }

            if (odometryReturnButton.dataset.manualBusy === '1') {
                return;
            }

            odometryReturnButton.textContent = defaultLabel;
            odometryReturnButton.disabled = !available;
        }

        function normalizePathPoints(path) {
            if (!Array.isArray(path) || path.length === 0) {
                return [{ x: 0, y: 0 }];
            }
            const cleaned = [];
            for (const point of path) {
                if (!point) continue;
                const x = Number(point.x);
                const y = Number(point.y);
                if (Number.isFinite(x) && Number.isFinite(y)) {
                    cleaned.push({ x, y });
                }
            }
            return cleaned.length ? cleaned : [{ x: 0, y: 0 }];
        }

        function drawOdometryPath() {
            if (!odometryCanvas || !odometryCtx) return;

            const ratio = window.devicePixelRatio || 1;
            const displayWidth = odometryCanvas.clientWidth || 220;
            const displayHeight = odometryCanvas.clientHeight || 220;
            const canvasWidth = Math.round(displayWidth * ratio);
            const canvasHeight = Math.round(displayHeight * ratio);

            if (odometryCanvas.width !== canvasWidth || odometryCanvas.height !== canvasHeight) {
                odometryCanvas.width = canvasWidth;
                odometryCanvas.height = canvasHeight;
            }

            odometryCtx.setTransform(ratio, 0, 0, ratio, 0, 0);
            odometryCtx.clearRect(0, 0, displayWidth, displayHeight);

            const points = telemetryState.path;
            if (!points || points.length === 0) {
                return;
            }

            const padding = 16;
            let minX = Infinity;
            let maxX = -Infinity;
            let minY = Infinity;
            let maxY = -Infinity;

            for (const pt of points) {
                if (!Number.isFinite(pt.x) || !Number.isFinite(pt.y)) continue;
                const plotX = pt.y;
                const plotY = pt.x;
                if (plotX < minX) minX = plotX;
                if (plotX > maxX) maxX = plotX;
                if (plotY < minY) minY = plotY;
                if (plotY > maxY) maxY = plotY;
            }

            if (!Number.isFinite(minX) || !Number.isFinite(minY)) {
                return;
            }

            if (minX === maxX) {
                minX -= 0.5;
                maxX += 0.5;
            }
            if (minY === maxY) {
                minY -= 0.5;
                maxY += 0.5;
            }

            const spanX = maxX - minX;
            const spanY = maxY - minY;
            const scale = Math.min(
                (displayWidth - padding * 2) / spanX,
                (displayHeight - padding * 2) / spanY
            );

            const offsetX = (displayWidth - spanX * scale) / 2;
            const offsetY = (displayHeight - spanY * scale) / 2;

            const project = (pt) => {
                const plotX = pt.y;
                const plotY = pt.x;
                return {
                    x: (plotX - minX) * scale + offsetX,
                    y: displayHeight - ((plotY - minY) * scale + offsetY),
                };
            };

            odometryCtx.strokeStyle = 'rgba(76, 175, 80, 0.9)';
            odometryCtx.lineWidth = 2;
            odometryCtx.beginPath();

            points.forEach((pt, index) => {
                const projected = project(pt);
                if (index === 0) {
                    odometryCtx.moveTo(projected.x, projected.y);
                } else {
                    odometryCtx.lineTo(projected.x, projected.y);
                }
            });
            odometryCtx.stroke();

            const startPoint = project(points[0]);
            const endPoint = project(points[points.length - 1]);

            odometryCtx.fillStyle = 'rgba(255, 255, 255, 0.55)';
            odometryCtx.beginPath();
            odometryCtx.arc(startPoint.x, startPoint.y, 4, 0, Math.PI * 2);
            odometryCtx.fill();

            odometryCtx.fillStyle = '#FFC107';
            odometryCtx.beginPath();
            odometryCtx.arc(endPoint.x, endPoint.y, 5, 0, Math.PI * 2);
            odometryCtx.fill();
        }

        function updateOdometryOverlay(odometry) {
            if (!odometry) {
                return;
            }

            telemetryState.sequence = odometry.sequence ?? telemetryState.sequence;
            telemetryState.path = normalizePathPoints(odometry.path);
            telemetryState.returnAvailable = Boolean(odometry.return_available);
            telemetryState.returnInProgress = Boolean(odometry.return_in_progress);

            const distance = Number(odometry.total_distance_ft);
            if (Number.isFinite(distance)) {
                telemetryState.totalDistance = distance;
            }

            updateDistanceLabel(telemetryState.totalDistance);
            drawOdometryPath();
            updateReturnButtonFromOdometry(odometry);
        }

        const odometryResetButton = document.getElementById('odometry-reset');
        if (odometryResetButton) {
            odometryResetButton.addEventListener('click', () => {
                telemetryState.resetPending = true;
                telemetryState.path = [{ x: 0, y: 0 }];
                telemetryState.totalDistance = 0;
                telemetryState.returnAvailable = false;
                telemetryState.returnInProgress = false;
                updateDistanceLabel(0);
                drawOdometryPath();
                if (odometryReturnButton) {
                    odometryReturnButton.dataset.manualBusy = '';
                    odometryReturnButton.textContent =
                        odometryReturnButton.dataset.defaultLabel || RETURN_BUTTON_LABEL;
                    odometryReturnButton.disabled = true;
                }
                if (socket && socket.connected) {
                    socket.emit('reset_odometry');
                }
            });
        }

        if (odometryReturnButton) {
            odometryReturnButton.addEventListener('click', () => {
                if (!socket || !socket.connected) {
                    return;
                }

                odometryReturnButton.dataset.manualBusy = '1';
                odometryReturnButton.disabled = true;
                odometryReturnButton.textContent = 'Returning...';
                socket.emit('return_to_start');
            });
        }

        window.addEventListener('resize', () => {
            drawOdometryPath();
        });

        drawOdometryPath();

        function toggleSettings(force) {
            const overlay = document.getElementById('settings-overlay');
            const button = document.getElementById('settings-btn');
            if (!overlay) return;

            let show;
            if (typeof force === 'boolean') {
                show = force;
            } else {
                show = overlay.classList.contains('hidden');
            }

            overlay.classList.toggle('hidden', !show);
            settingsVisible = show;

            if (button) {
                button.classList.toggle('active', show);
            }

            if (show) {
                initializeWifiSettings();
                const now = Date.now();
                if (!wifiState.lastScan || (now - wifiState.lastScan) > 15000 || !wifiState.networks.length) {
                    refreshWifiNetworks(true);
                } else {
                    renderWifiNetworks();
                    updateWifiStatusDisplay();
                    updateWifiSelectionUI();
                    updateWifiConnectAvailability();
                }
            }
        }

        function closeSettingsIfOpen() {
            if (settingsVisible) {
                toggleSettings(false);
            }
        }

        function isFormElement(target) {
            if (!target) return false;
            if (target.isContentEditable) return true;
            const tag = target.tagName;
            return tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeSettingsIfOpen();
            }
            handleKeyboardEvent(event, true);
        });

        document.addEventListener('keyup', (event) => {
            handleKeyboardEvent(event, false);
        });

        document.addEventListener('click', (event) => {
            if (!settingsVisible) return;
            const overlay = document.getElementById('settings-overlay');
            const panel = document.getElementById('settings-panel');
            if (!overlay || !panel) return;
            const button = document.getElementById('settings-btn');
            if (panel.contains(event.target) || (button && button.contains(event.target))) {
                return;
            }
            toggleSettings(false);
        });

        function onInputMethodChange(value) {
            setInputMethod(value);
        }

        function updateInputMethodUI() {
            const options = document.querySelectorAll('#input-method-options .radio-option');
            options.forEach((option) => {
                const input = option.querySelector('input[type="radio"]');
                if (!input) return;
                const isActive = input.value === inputState.method;
                if (input.checked !== isActive) {
                    input.checked = isActive;
                }
                option.classList.toggle('active', isActive);
            });
        }

        function updateGamepadStatus(text, connected = false) {
            const statusEl = document.getElementById('gamepad-status');
            if (statusEl) {
                statusEl.textContent = text;
            }
            inputState.gamepadConnected = connected;
        }

        function getGamepadList() {
            const getPadsFn = navigator.getGamepads || navigator.webkitGetGamepads || navigator.msGetGamepads;
            if (!getPadsFn) {
                return null;
            }
            try {
                return getPadsFn.call(navigator);
            } catch (err) {
                console.warn('Unable to query gamepads:', err);
                return null;
            }
        }

        function getActiveGamepad() {
            const pads = getGamepadList();
            if (!pads) return null;

            if (inputState.gamepadIndex !== null && pads.length > inputState.gamepadIndex) {
                const indexedPad = pads[inputState.gamepadIndex];
                if (indexedPad && indexedPad.connected) {
                    return indexedPad;
                }
            }

            const length = typeof pads.length === 'number' ? pads.length : 0;
            for (let i = 0; i < length; i++) {
                const pad = pads[i];
                if (pad && pad.connected) {
                    inputState.gamepadIndex = pad.index ?? i;
                    return pad;
                }
            }

            return null;
        }

        function stopGamepadPolling() {
            if (inputState.pollHandle) {
                cancelAnimationFrame(inputState.pollHandle);
                inputState.pollHandle = null;
            }
            inputState.lastLeft = 0;
            inputState.lastRight = 0;
            inputState.gamepadIndex = null;
        }

        function applyGamepadDeadZone(value) {
            if (Math.abs(value) < GAMEPAD_DEAD_ZONE) {
                return 0;
            }
            return Math.max(-1, Math.min(1, value));
        }

        function getGamepadAxis(gamepad, primaryIndex, fallbackIndex = null) {
            if (!gamepad || !gamepad.axes) return 0;
            const primary = gamepad.axes[primaryIndex];
            if (typeof primary === 'number' && Number.isFinite(primary)) {
                return primary;
            }
            if (fallbackIndex !== null) {
                const fallback = gamepad.axes[fallbackIndex];
                if (typeof fallback === 'number' && Number.isFinite(fallback)) {
                    return fallback;
                }
            }
            return 0;
        }

        function applySpeedCurve(value) {
            return Math.sign(value) * Math.pow(Math.abs(value), SPEED_CURVE_EXPONENT);
        }

        function processGamepadInput(gamepad) {
            if (!gamepad) {
                if (inputState.lastLeft !== 0 || inputState.lastRight !== 0) {
                    inputState.lastLeft = 0;
                    inputState.lastRight = 0;
                    setControlValues(0, 0, true);
                }
                return;
            }

            let leftPercent = 0;
            let rightPercent = 0;

            if (controlState.mode === 'joystick') {
                const rawForward = -applyGamepadDeadZone(getGamepadAxis(gamepad, 1));
                const rawTurn = applyGamepadDeadZone(getGamepadAxis(gamepad, 0)) * JOYSTICK_TURN_SENSITIVITY;
                let left = rawForward + rawTurn;
                let right = rawForward - rawTurn;
                const maxMagnitude = Math.max(1, Math.max(Math.abs(left), Math.abs(right)));
                left = applySpeedCurve(left / maxMagnitude);
                right = applySpeedCurve(right / maxMagnitude);
                leftPercent = Math.round(left * 100);
                rightPercent = Math.round(right * 100);
            } else {
                const leftRaw = -applyGamepadDeadZone(getGamepadAxis(gamepad, 1));
                const rightRaw = -applyGamepadDeadZone(getGamepadAxis(gamepad, 3, 5));
                leftPercent = Math.round(applySpeedCurve(leftRaw) * 100);
                rightPercent = Math.round(applySpeedCurve(rightRaw) * 100);
            }

            if (Math.abs(leftPercent) < SPEED_DEAD_ZONE) leftPercent = 0;
            if (Math.abs(rightPercent) < SPEED_DEAD_ZONE) rightPercent = 0;

            if (leftPercent !== inputState.lastLeft || rightPercent !== inputState.lastRight) {
                inputState.lastLeft = leftPercent;
                inputState.lastRight = rightPercent;
                setControlValues(leftPercent, rightPercent);
            }
        }

        function pollGamepad() {
            if (inputState.method !== 'xbox') {
                stopGamepadPolling();
                return;
            }

            const gamepad = getActiveGamepad();
            if (gamepad) {
                if (!inputState.gamepadConnected || inputState.gamepadName !== gamepad.id) {
                    inputState.gamepadName = gamepad.id;
                    updateGamepadStatus(`Connected: ${gamepad.id}`, true);
                }
                processGamepadInput(gamepad);
            } else {
                if (inputState.gamepadConnected) {
                    updateGamepadStatus('Gamepad disconnected.', false);
                }
                processGamepadInput(null);
            }

            inputState.pollHandle = requestAnimationFrame(pollGamepad);
        }

        function startGamepadPolling() {
            if (inputState.pollHandle) return;
            pollGamepad();
        }

        function setInputMethod(method) {
            if (method !== 'onscreen' && method !== 'xbox' && method !== 'keyboard') {
                method = 'onscreen';
            }

            if (inputState.method === method) {
                updateInputMethodUI();
                refreshControlVisibility();
                if (method === 'keyboard') {
                    updateKeyboardControl();
                }
                return;
            }

            if (inputState.method === 'keyboard' && method !== 'keyboard') {
                resetKeyboardState();
            }

            inputState.method = method;
            updateInputMethodUI();

            if (method === 'xbox') {
                if (!navigator.getGamepads) {
                    updateGamepadStatus('Gamepad API not supported in this browser.', false);
                    stopGamepadPolling();
                } else {
                    const existingPad = getActiveGamepad();
                    if (existingPad) {
                        inputState.gamepadName = existingPad.id;
                        updateGamepadStatus(`Connected: ${existingPad.id}`, true);
                    } else if (inputState.gamepadConnected && inputState.gamepadName) {
                        updateGamepadStatus(`Connected: ${inputState.gamepadName}`, true);
                    } else {
                        updateGamepadStatus('Waiting for Xbox controller...', false);
                    }
                    startGamepadPolling();
                }
                if (joystickControl) joystickControl.cancel();
                if (leftSlider) leftSlider.cancel();
                if (rightSlider) rightSlider.cancel();
                setControlValues(0, 0, true);
            } else if (method === 'keyboard') {
                stopGamepadPolling();
                updateGamepadStatus('Keyboard input active. Use WASD or arrow keys.', false);
                if (joystickControl) joystickControl.cancel();
                if (leftSlider) leftSlider.cancel();
                if (rightSlider) rightSlider.cancel();
                keyboardState.keys.clear();
                keyboardState.lastLeft = 0;
                keyboardState.lastRight = 0;
                setControlValues(0, 0, true);
                updateKeyboardControl();
            } else {
                updateGamepadStatus('No gamepad detected.', false);
                stopGamepadPolling();
                setControlValues(0, 0, true);
            }

            refreshControlVisibility();
        }

        function resetKeyboardState() {
            keyboardState.keys.clear();
            if (keyboardState.lastLeft !== 0 || keyboardState.lastRight !== 0) {
                keyboardState.lastLeft = 0;
                keyboardState.lastRight = 0;
                setControlValues(0, 0, true);
            }
        }

        function handleKeyboardEvent(event, isKeyDown) {
            if (inputState.method !== 'keyboard') return;
            if (isFormElement(event.target)) return;

            if (!KEYBOARD_CONTROL_CODES.has(event.code)) {
                return;
            }

            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.code)) {
                event.preventDefault();
            }

            if (isKeyDown) {
                if (!event.repeat) {
                    keyboardState.keys.add(event.code);
                    updateKeyboardControl();
                }
            } else {
                if (keyboardState.keys.delete(event.code)) {
                    updateKeyboardControl();
                }
            }
        }

        function updateKeyboardControl() {
            if (inputState.method !== 'keyboard') return;

            let leftPercent = 0;
            let rightPercent = 0;

            if (controlState.mode === 'tank') {
                const leftForward = keyboardState.keys.has('KeyW');
                const leftReverse = keyboardState.keys.has('KeyS');
                const rightForward = keyboardState.keys.has('ArrowUp');
                const rightReverse = keyboardState.keys.has('ArrowDown');

                if (leftForward && !leftReverse) {
                    leftPercent = 100;
                } else if (leftReverse && !leftForward) {
                    leftPercent = -100;
                }

                if (rightForward && !rightReverse) {
                    rightPercent = 100;
                } else if (rightReverse && !rightForward) {
                    rightPercent = -100;
                }
            } else {
                let forward = 0;
                let turn = 0;

                const forwardKeys = keyboardState.keys.has('KeyW') || keyboardState.keys.has('ArrowUp');
                const backwardKeys = keyboardState.keys.has('KeyS') || keyboardState.keys.has('ArrowDown');
                const turnLeftKeys = keyboardState.keys.has('KeyA') || keyboardState.keys.has('ArrowLeft');
                const turnRightKeys = keyboardState.keys.has('KeyD') || keyboardState.keys.has('ArrowRight');

                if (forwardKeys && !backwardKeys) {
                    forward = 1;
                } else if (backwardKeys && !forwardKeys) {
                    forward = -1;
                }

                if (turnRightKeys && !turnLeftKeys) {
                    turn = 1;
                } else if (turnLeftKeys && !turnRightKeys) {
                    turn = -1;
                }

                turn *= JOYSTICK_TURN_SENSITIVITY;

                let left = forward + turn;
                let right = forward - turn;

                const maxMagnitude = Math.max(1, Math.max(Math.abs(left), Math.abs(right)));
                left = applySpeedCurve(left / maxMagnitude);
                right = applySpeedCurve(right / maxMagnitude);

                leftPercent = Math.round(left * 100);
                rightPercent = Math.round(right * 100);

                if (Math.abs(leftPercent) < SPEED_DEAD_ZONE) leftPercent = 0;
                if (Math.abs(rightPercent) < SPEED_DEAD_ZONE) rightPercent = 0;
            }

            if (leftPercent !== keyboardState.lastLeft || rightPercent !== keyboardState.lastRight) {
                keyboardState.lastLeft = leftPercent;
                keyboardState.lastRight = rightPercent;
                setControlValues(leftPercent, rightPercent, true);
            }
        }

        function refreshControlVisibility() {
            const tankControls = document.getElementById('tank-controls');
            const joystickControls = document.getElementById('joystick-control');

            if (!tankControls || !joystickControls) return;

            if (inputState.method === 'xbox' || inputState.method === 'keyboard') {
                tankControls.classList.add('hidden');
                joystickControls.classList.add('hidden');
                return;
            }

            if (controlState.mode === 'joystick') {
                tankControls.classList.add('hidden');
                joystickControls.classList.remove('hidden');
            } else {
                tankControls.classList.remove('hidden');
                joystickControls.classList.add('hidden');
            }
        }

        function applyDefaultInputMethod() {
            if (!navigator.getGamepads) {
                updateGamepadStatus('No gamepad detected.', false);
                if (inputState.method !== 'onscreen') {
                    setInputMethod('onscreen');
                }
                return;
            }

            const pad = getActiveGamepad();
            if (pad) {
                inputState.gamepadName = pad.id;
                updateGamepadStatus(`Connected: ${pad.id}`, true);
                if (inputState.method !== 'xbox') {
                    setInputMethod('xbox');
                } else {
                    startGamepadPolling();
                }
            } else {
                updateGamepadStatus('No gamepad detected.', false);
                if (inputState.method !== 'onscreen') {
                    setInputMethod('onscreen');
                }
            }
        }

        window.addEventListener('gamepadconnected', (event) => {
            inputState.gamepadIndex = event.gamepad.index;
            inputState.gamepadName = event.gamepad.id;
            updateGamepadStatus(`Connected: ${event.gamepad.id}`, true);
            if (inputState.method === 'keyboard') {
                return;
            }
            if (inputState.method === 'xbox') {
                startGamepadPolling();
            } else {
                setInputMethod('xbox');
            }
        });

        window.addEventListener('gamepaddisconnected', (event) => {
            if (event.gamepad.index === inputState.gamepadIndex) {
                inputState.gamepadIndex = null;
                inputState.gamepadName = '';
            }
            const replacement = getActiveGamepad();
            if (replacement) {
                inputState.gamepadIndex = replacement.index ?? inputState.gamepadIndex;
                inputState.gamepadName = replacement.id;
                updateGamepadStatus(`Connected: ${replacement.id}`, true);
                if (inputState.method === 'xbox') {
                    startGamepadPolling();
                }
            } else {
                updateGamepadStatus('Gamepad disconnected.', false);
                if (inputState.method === 'xbox') {
                    setInputMethod('onscreen');
                }
            }
        });

        socket.on('connect', () => {
            document.getElementById('connection-status').textContent = 'Connected';
            document.getElementById('connection-status').style.color = '#4CAF50';
        });
        
        socket.on('disconnect', () => {
            document.getElementById('connection-status').textContent = 'Disconnected';
            document.getElementById('connection-status').style.color = '#f44336';
        });

        socket.on('telemetry', (payload) => {
            updateBatteryIndicator(payload ? payload.battery : null);
            if (payload && payload.odometry) {
                updateOdometryOverlay(payload.odometry);
            }
        });

        socket.on('odometry_reset', (payload) => {
            telemetryState.resetPending = false;
            if (payload && payload.success && Number.isFinite(payload.sequence)) {
                telemetryState.sequence = payload.sequence;
            }
        });

        socket.on('return_to_start_status', (payload) => {
            if (!odometryReturnButton) return;
            const defaultLabel = odometryReturnButton.dataset.defaultLabel || RETURN_BUTTON_LABEL;

            if (!payload || !payload.success) {
                if (payload && payload.message) {
                    console.warn(payload.message);
                }
                odometryReturnButton.dataset.manualBusy = '';
                odometryReturnButton.textContent = defaultLabel;
                odometryReturnButton.disabled = !telemetryState.returnAvailable;
                return;
            }

            odometryReturnButton.dataset.manualBusy = '1';
            odometryReturnButton.disabled = true;
            odometryReturnButton.textContent = 'Returning...';
        });

        socket.on('return_to_start_complete', (payload) => {
            if (!odometryReturnButton) return;
            const defaultLabel = odometryReturnButton.dataset.defaultLabel || RETURN_BUTTON_LABEL;
            const success = payload && payload.success;

            if (!success && payload && payload.reason) {
                console.warn(`Return-to-start interrupted: ${payload.reason}`);
            }

            odometryReturnButton.dataset.manualBusy = '';
            odometryReturnButton.textContent = defaultLabel;
            if (success) {
                odometryReturnButton.disabled = true;
            } else {
                odometryReturnButton.disabled = !telemetryState.returnAvailable;
            }

            updateReturnButtonFromOdometry({
                return_available: telemetryState.returnAvailable,
                return_in_progress: telemetryState.returnInProgress,
            });
        });

        // Camera management
        function startCameras() {
            console.log('Starting cameras...');
            document.getElementById('camera-start-overlay').style.display = 'none';
            document.getElementById('camera-error').style.display = 'none';
            
            // Start front camera
            const frontVideo = document.getElementById('front-video');
            frontVideo.onerror = function() {
                console.error('Front camera failed to load');
                document.getElementById('front-status').className = 'status-dot inactive';
                frontCameraActive = false;
                checkCameraStatus();
            };
            
            frontVideo.onload = function() {
                console.log('Front camera loaded');
                frontVideo.style.display = 'block';
                document.getElementById('front-status').className = 'status-dot active';
                frontCameraActive = true;
                camerasActive = true;
            };
            
            // Add timestamp to force reload
            frontVideo.src = '/video_feed/front?' + Date.now();
            
            // Start rear camera with delay
            setTimeout(() => {
                const rearVideo = document.getElementById('rear-video');
                rearVideo.onerror = function() {
                    console.error('Rear camera failed to load');
                    document.getElementById('rear-status').className = 'status-dot inactive';
                    rearCameraActive = false;
                };
                
                rearVideo.onload = function() {
                    console.log('Rear camera loaded');
                    rearVideo.style.display = 'block';
                    document.getElementById('rear-status').className = 'status-dot active';
                    rearCameraActive = true;
                };
                
                rearVideo.src = '/video_feed/rear?' + Date.now();
            }, 500);
            
            // Show camera status panel
            document.getElementById('camera-status').style.display = 'block';
            document.getElementById('camera-btn').classList.add('active');
            
            // Check status after 3 seconds
            setTimeout(checkCameraStatus, 3000);
        }
        
        function stopCameras() {
            console.log('Stopping cameras...');
            document.getElementById('front-video').src = '';
            document.getElementById('front-video').style.display = 'none';
            document.getElementById('rear-video').src = '';
            document.getElementById('rear-video').style.display = 'none';
            document.getElementById('camera-status').style.display = 'none';
            document.getElementById('camera-btn').classList.remove('active');
            document.getElementById('camera-start-overlay').style.display = 'block';
            
            camerasActive = false;
            frontCameraActive = false;
            rearCameraActive = false;
        }
        
        function toggleCamera() {
            if (camerasActive) {
                stopCameras();
            } else {
                startCameras();
            }
        }
        
        function retryCameras() {
            document.getElementById('camera-error').style.display = 'none';
            startCameras();
        }
        
        function checkCameraStatus() {
            if (!frontCameraActive && !rearCameraActive) {
                document.getElementById('camera-error').style.display = 'block';
                document.getElementById('error-message').textContent = 
                    'No cameras detected. Check camera connections.';
            } else if (!frontCameraActive) {
                console.warn('Front camera not available, using rear only');
            } else if (!rearCameraActive) {
                console.warn('Rear camera not available, using front only');
            }
        }
        
        // Motor control
        const controlState = {
            mode: 'joystick',
            left: 0,
            right: 0
        };

        let leftSlider;
        let rightSlider;
        let joystickControl;

        function clampPercent(value) {
            if (!Number.isFinite(value)) return 0;
            return Math.max(-100, Math.min(100, Math.round(value)));
        }

        function queueMotorCommand(force = false) {
            const now = performance.now();
            const timeSinceLast = now - lastMotorSend;
            const send = () => {
                const payload = { left: -controlState.left, right: -controlState.right };
                socket.volatile.emit('motor_control', payload);
                document.getElementById('status').textContent =
                    `Speed: L=${controlState.left}% R=${controlState.right}%`;
                lastMotorSend = performance.now();
                motorSendScheduled = false;
            };

            if (force) {
                send();
                return;
            }

            if (timeSinceLast >= MOTOR_COMMAND_INTERVAL) {
                send();
            } else if (!motorSendScheduled) {
                motorSendScheduled = true;
                setTimeout(() => send(), MOTOR_COMMAND_INTERVAL - timeSinceLast);
            }
        }

        function setControlSide(side, value, force = false) {
            controlState[side] = clampPercent(value);
            queueMotorCommand(force);
        }

        function setControlValues(left, right, force = false) {
            controlState.left = clampPercent(left);
            controlState.right = clampPercent(right);
            queueMotorCommand(force);
        }

        function onControlToggle(checked) {
            setControlMode(checked ? 'joystick' : 'tank');
        }

        function setControlMode(mode) {
            if (mode !== 'tank' && mode !== 'joystick') return;
            if (controlState.mode === mode) {
                const toggleInput = document.getElementById('control-toggle');
                if (toggleInput && toggleInput.checked !== (mode === 'joystick')) {
                    toggleInput.checked = mode === 'joystick';
                }
                return;
            }

            controlState.mode = mode;

            const toggleInput = document.getElementById('control-toggle');

            if (toggleInput && toggleInput.checked !== (mode === 'joystick')) {
                toggleInput.checked = mode === 'joystick';
            }

            if (joystickControl) joystickControl.cancel();
            if (leftSlider) leftSlider.cancel();
            if (rightSlider) rightSlider.cancel();

            setControlValues(0, 0, true);
            if (inputState.method === 'keyboard') {
                keyboardState.lastLeft = 0;
                keyboardState.lastRight = 0;
                updateKeyboardControl();
            }
            refreshControlVisibility();
        }

        class MotorSlider {
            constructor(element, side) {
                this.thumb = element;
                this.side = side;
                this.value = 0;
                this.pointerId = null;
                this.dragging = false;
                this.track = this.thumb.parentElement;
                this.track.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                this.thumb.addEventListener('pointerdown', (e) => this.startDrag(e));
                this.thumb.addEventListener('pointermove', (e) => this.onPointerMove(e));
                this.thumb.addEventListener('pointerup', (e) => this.endDrag(e));
                this.thumb.addEventListener('pointercancel', (e) => this.endDrag(e));
                this.resetThumb(false);
            }

            startDrag(e) {
                if (controlState.mode !== 'tank' || inputState.method !== 'onscreen') return;
                e.preventDefault();
                this.dragging = true;
                this.pointerId = e.pointerId;
                this.thumb.setPointerCapture(this.pointerId);
                this.thumb.classList.add('active');
                this.thumb.style.transition = '';
                this.updateValueFromEvent(e);
            }

            onPointerMove(e) {
                if (!this.dragging || e.pointerId !== this.pointerId) return;
                this.updateValueFromEvent(e);
            }

            endDrag(e) {
                if (!this.dragging || (e && e.pointerId !== this.pointerId)) return;
                this.releasePointer();
                this.dragging = false;
                this.value = 0;
                this.resetThumb(true);
                setControlSide(this.side, this.value, true);
            }

            releasePointer() {
                if (this.pointerId !== null) {
                    try { this.thumb.releasePointerCapture(this.pointerId); } catch (err) {}
                }
                this.pointerId = null;
                this.thumb.classList.remove('active');
            }

            cancel() {
                this.releasePointer();
                this.dragging = false;
                this.value = 0;
                this.resetThumb(false);
            }

            updateValueFromEvent(e) {
                if (controlState.mode !== 'tank') return;
                const rect = this.track.getBoundingClientRect();
                const thumbHeight = this.thumb.offsetHeight;
                const range = Math.max(1, rect.height - thumbHeight);
                const y = e.clientY - rect.top - thumbHeight / 2;
                const clamped = Math.max(0, Math.min(range, y));
                this.thumb.style.top = `${clamped}px`;

                const normalized = 1 - (clamped / range);
                const symmetric = normalized * 2 - 1;
                const magnitude = Math.pow(Math.abs(symmetric), SPEED_CURVE_EXPONENT);
                const curved = symmetric >= 0 ? magnitude : -magnitude;
                let value = Math.round(curved * 100);
                if (Math.abs(value) < SPEED_DEAD_ZONE) {
                    value = 0;
                }
                this.value = Math.max(-100, Math.min(100, value));
                setControlSide(this.side, this.value);
            }

            resetThumb(animate = true) {
                const thumbHeight = this.thumb.offsetHeight;
                const range = this.track.offsetHeight - thumbHeight;
                const center = range / 2;
                this.thumb.classList.remove('active');
                if (animate) {
                    this.thumb.style.transition = 'top 0.12s ease-out';
                } else {
                    this.thumb.style.transition = '';
                }
                this.thumb.style.top = `${center}px`;
                if (animate) {
                    setTimeout(() => { this.thumb.style.transition = ''; }, 150);
                }
            }
        }

        class JoystickControl {
            constructor(baseElement, thumbElement) {
                this.base = baseElement;
                this.thumb = thumbElement;
                this.pointerId = null;
                this.active = false;

                this.base.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                this.base.addEventListener('pointerdown', (e) => this.start(e));
                this.base.addEventListener('pointermove', (e) => this.move(e));
                this.base.addEventListener('pointerup', (e) => this.end(e));
                this.base.addEventListener('pointercancel', (e) => this.end(e));
            }

            start(e) {
                if (controlState.mode !== 'joystick' || inputState.method !== 'onscreen') return;
                e.preventDefault();
                this.active = true;
                this.pointerId = e.pointerId;
                this.base.setPointerCapture(this.pointerId);
                this.thumb.style.transition = 'none';
                this.base.classList.add('active');
                this.updateFromEvent(e);
            }

            move(e) {
                if (!this.active || e.pointerId !== this.pointerId) return;
                this.updateFromEvent(e);
            }

            end(e) {
                if (!this.active || (e && e.pointerId !== this.pointerId)) return;
                if (this.pointerId !== null) {
                    try { this.base.releasePointerCapture(this.pointerId); } catch (err) {}
                }
                this.pointerId = null;
                this.active = false;
                this.reset(true);
                setControlValues(0, 0, true);
            }

            cancel() {
                if (this.pointerId !== null) {
                    try { this.base.releasePointerCapture(this.pointerId); } catch (err) {}
                }
                this.pointerId = null;
                this.active = false;
                this.reset(false);
            }

            updateFromEvent(e) {
                if (controlState.mode !== 'joystick' || inputState.method !== 'onscreen') return;
                const rect = this.base.getBoundingClientRect();
                const radius = rect.width / 2;
                if (radius <= 0) return;

                let offsetX = e.clientX - (rect.left + radius);
                let offsetY = e.clientY - (rect.top + radius);
                const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
                if (distance > radius) {
                    const scale = radius / distance;
                    offsetX *= scale;
                    offsetY *= scale;
                }

                this.thumb.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;

                const normalizedX = offsetX / radius;
                const normalizedY = -offsetY / radius;

                let forward = normalizedY;
                let turn = normalizedX * JOYSTICK_TURN_SENSITIVITY;

                let left = forward + turn;
                let right = forward - turn;

                const maxMagnitude = Math.max(1, Math.max(Math.abs(left), Math.abs(right)));
                left /= maxMagnitude;
                right /= maxMagnitude;

                let leftCurved = Math.sign(left) * Math.pow(Math.abs(left), SPEED_CURVE_EXPONENT);
                let rightCurved = Math.sign(right) * Math.pow(Math.abs(right), SPEED_CURVE_EXPONENT);

                let leftPercent = Math.round(leftCurved * 100);
                let rightPercent = Math.round(rightCurved * 100);

                if (Math.abs(leftPercent) < SPEED_DEAD_ZONE) leftPercent = 0;
                if (Math.abs(rightPercent) < SPEED_DEAD_ZONE) rightPercent = 0;

                setControlValues(leftPercent, rightPercent);
            }

            reset(animate = true) {
                this.base.classList.remove('active');
                if (animate) {
                    this.thumb.style.transition = 'transform 0.12s ease-out';
                } else {
                    this.thumb.style.transition = '';
                }
                this.thumb.style.transform = 'translate(-50%, -50%)';
                if (animate) {
                    setTimeout(() => { this.thumb.style.transition = ''; }, 150);
                }
            }
        }

        leftSlider = new MotorSlider(document.getElementById('left-thumb'), 'left');
        rightSlider = new MotorSlider(document.getElementById('right-thumb'), 'right');
        joystickControl = new JoystickControl(
            document.getElementById('joystick-base'),
            document.getElementById('joystick-thumb')
        );

        setControlMode(controlState.mode);
        refreshControlVisibility();
        updateInputMethodUI();
        applyDefaultInputMethod();

        function emergencyStop() {
            socket.emit('emergency_stop');
            if (leftSlider) leftSlider.cancel();
            if (rightSlider) rightSlider.cancel();
            if (joystickControl) joystickControl.cancel();
            setControlValues(0, 0, true);
            document.getElementById('status').textContent = 'STOPPED';
        }

        function shutdownCrawler() {
            if (!confirm('Shut down the crawler?\n\nAfter shutdown completes you must flip the power switch.')) {
                return;
            }

            fetch('/api/shutdown', { method: 'POST' })
                .then(res => {
                    if (!res.ok) throw new Error('Failed to request shutdown');
                    alert('Shutdown requested. Wait for the Pi to power down, then flip the main switch.');
                })
                .catch(err => {
                    console.error(err);
                    alert('Unable to request shutdown. Check connection and try again.');
                });
        }

        function changeStreamQuality(profile) {
            fetch('/api/camera/quality', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ profile })
            }).then(res => {
                if (!res.ok) throw new Error('Quality change failed');
            }).catch(err => {
                console.error(err);
                alert('Could not change camera quality.');
            });
        }

        function refreshStatus() {
            fetch('/api/status')
                .then(res => res.json())
                .then(data => {
                    const select = document.getElementById('quality-select');
                    if (!select) {
                        return;
                    }

                    const profile = data && data.cameras ? data.cameras.profile : null;
                    if (profile) {
                        if (select.value !== profile) {
                            select.value = profile;
                        }
                        cameraProfileInitialized = true;
                    } else if (!cameraProfileInitialized) {
                        if (select.value !== 'low') {
                            select.value = 'low';
                        }
                        cameraProfileInitialized = true;
                        changeStreamQuality('low');
                    } else if (!select.value) {
                        select.value = 'low';
                    }
                })
                .catch(() => {
                    const select = document.getElementById('quality-select');
                    if (select && !cameraProfileInitialized && select.value !== 'low') {
                        select.value = 'low';
                    }
                });
        }

        setInterval(refreshStatus, 2000);
        refreshStatus();
    </script>
</body>
</html>
