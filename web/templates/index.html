<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Crawler Control</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }
        
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0,0,0,0.8);
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 100;
            gap: 12px;
        }

        #header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #header-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #settings-btn {
            width: 40px;
            height: 40px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0;
        }

        #settings-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }

        .toggle-container span {
            color: #bbb;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: 0.2s;
            border-radius: 12px;
        }

        .toggle-slider::before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: #fff;
            transition: 0.2s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #4CAF50;
        }

        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(22px);
        }

        .btn {
            background: #333;
            color: #fff;
            border: none;
            padding: 10px 15px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .btn:hover { background: #555; }
        .btn.active { background: #4CAF50; }
        .btn.emergency { background: #d32f2f; }
        .btn.shutdown { background: #f57c00; }

        #quality-select {
            background: #222;
            color: #fff;
            border: 1px solid #444;
            padding: 8px 10px;
            border-radius: 4px;
        }

        #settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        #settings-overlay.hidden {
            display: none;
        }

        #settings-panel {
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            width: min(420px, 90vw);
            padding: 20px 24px;
            box-shadow: 0 20px 45px rgba(0, 0, 0, 0.45);
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .settings-header h3 {
            font-size: 20px;
            font-weight: 600;
        }

        #settings-close {
            background: transparent;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
        }

        #settings-close:hover {
            color: #4CAF50;
        }

        .settings-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .settings-section label {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            color: rgba(255, 255, 255, 0.7);
        }

        .settings-option-group {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .radio-option {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.06);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid transparent;
        }

        .radio-option input {
            accent-color: #4CAF50;
        }

        .radio-option.active {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.18);
        }

        #video-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #111;
        }
        
        #camera-start-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 50;
        }
        
        #camera-start-overlay button {
            padding: 20px 40px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        #camera-start-overlay button:hover {
            background: #5CBF60;
        }
        
        #front-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none;
            transform: scaleY(-1);
        }
        
        #rear-video {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            height: 240px;
            border: 2px solid #444;
            border-radius: 10px;
            background: #222;
            display: none;
            object-fit: cover;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
        }

        .camera-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #f44336;
            display: none;
        }
        
        .hidden {
            display: none !important;
        }

        .control-slider {
            position: fixed;
            width: 60px;
            height: 400px;
            background: rgba(255,255,255,0.1);
            border-radius: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-slider.left { left: 20px; bottom: 100px; }
        .control-slider.right { right: 20px; bottom: 100px; }

        #joystick-control {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 14px;
        }

        #joystick-base {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: rgba(255,255,255,0.08);
            border: 2px solid rgba(255,255,255,0.18);
            position: relative;
            touch-action: none;
            box-shadow: inset 0 10px 25px rgba(0,0,0,0.35);
        }

        #joystick-base.active {
            background: rgba(76,175,80,0.18);
            border-color: rgba(76,175,80,0.45);
        }

        #joystick-thumb {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #4CAF50;
            border: 3px solid #fff;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 12px 25px rgba(0,0,0,0.4);
            transition: transform 0.12s ease-out;
        }

        .joystick-label {
            font-size: 12px;
            letter-spacing: 2px;
            color: rgba(255,255,255,0.7);
        }

        .slider-track {
            width: 40px;
            height: 375px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            position: relative;
        }

        .slider-thumb {
            width: 36px;
            height: 36px;
            background: #4CAF50;
            border-radius: 50%;
            position: absolute;
            left: 2px;
            top: 0;
            cursor: pointer;
            border: 2px solid #fff;
        }
        
        .control-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 12px;
        }
        
        #status {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 10px;
            background: rgba(0,0,0,0.7);
            border-radius: 5px;
            font-size: 14px;
        }
        
        .camera-status {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-dot.active { background: #4CAF50; }
        .status-dot.inactive { background: #f44336; }
    </style>
</head>
<body>
    <div id="header">
        <div id="header-left">
            <h2>ü§ñ Crawler</h2>
            <span id="connection-status">Disconnected</span>
        </div>
        <div id="header-controls">
            <button id="settings-btn" class="btn" onclick="toggleSettings()" title="Settings">‚öôÔ∏è</button>
            <button id="camera-btn" class="btn" onclick="toggleCamera()">üìπ Camera</button>
            <button class="btn emergency" onclick="emergencyStop()">üõë STOP</button>
            <button class="btn shutdown" onclick="shutdownCrawler()">‚èª Shutdown</button>
        </div>
    </div>
    
    <div id="video-container">
        <div id="camera-start-overlay">
            <button onclick="startCameras()">üìπ Start Cameras</button>
            <p style="margin-top: 20px; color: #999;">Click to start camera streams</p>
        </div>
        
        <div class="camera-error" id="camera-error">
            <h3>Camera Error</h3>
            <p id="error-message"></p>
            <button class="btn" onclick="retryCameras()">Retry</button>
        </div>
        
        <img id="front-video" alt="Front Camera">
        <img id="rear-video" alt="Rear Camera">
        
        <div class="camera-status" id="camera-status" style="display: none;">
            <div><span class="status-dot" id="front-status"></span>Front Camera</div>
            <div><span class="status-dot" id="rear-status"></span>Rear Camera</div>
        </div>
    </div>
    
    <div id="tank-controls">
        <div class="control-slider left">
            <div class="slider-track">
                <div class="slider-thumb" id="left-thumb"></div>
            </div>
            <div class="control-label">LEFT</div>
        </div>

        <div class="control-slider right">
            <div class="slider-track">
                <div class="slider-thumb" id="right-thumb"></div>
            </div>
            <div class="control-label">RIGHT</div>
        </div>
    </div>

    <div id="joystick-control" class="hidden">
        <div id="joystick-base">
            <div id="joystick-thumb"></div>
        </div>
        <div class="joystick-label">JOYSTICK</div>
    </div>
    
    <div id="status">Speed: L=0% R=0%</div>

    <div id="settings-overlay" class="hidden">
        <div id="settings-panel">
            <div class="settings-header">
                <h3>Settings</h3>
                <button id="settings-close" onclick="toggleSettings()" aria-label="Close settings">‚úï</button>
            </div>

            <div class="settings-section">
                <label for="quality-select">Video Quality</label>
                <select id="quality-select" onchange="changeStreamQuality(this.value)">
                    <option value="balanced">Balanced</option>
                    <option value="low">Low Lag</option>
                    <option value="high">High Detail</option>
                </select>
            </div>

            <div class="settings-section">
                <label>Control Style</label>
                <div class="settings-option-group">
                    <div class="toggle-container" title="Toggle control scheme">
                        <span>Tank</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="control-toggle" onchange="onControlToggle(this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Joystick</span>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <label>Input Device</label>
                <div class="settings-option-group" id="input-method-options">
                    <label class="radio-option active">
                        <input type="radio" name="input-method" value="onscreen" checked onchange="onInputMethodChange(this.value)">
                        <span>On-Screen Controls</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="input-method" value="xbox" onchange="onInputMethodChange(this.value)">
                        <span>Xbox Controller</span>
                    </label>
                </div>
                <small id="gamepad-status" style="color: rgba(255,255,255,0.6);">No gamepad detected.</small>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // WebSocket connection
        const socket = io();
        let camerasActive = false;
        let frontCameraActive = false;
        let rearCameraActive = false;
        let motorSendScheduled = false;
        let lastMotorSend = 0;
        const MOTOR_COMMAND_INTERVAL = 60; // ms
        const SPEED_CURVE_EXPONENT = 2.4;
        const SPEED_DEAD_ZONE = 8;
        const GAMEPAD_DEAD_ZONE = 0.18;
        const JOYSTICK_TURN_SENSITIVITY = 0.65;

        const inputState = {
            method: 'onscreen',
            gamepadIndex: null,
            pollHandle: null,
            lastLeft: 0,
            lastRight: 0,
            gamepadConnected: false,
            gamepadName: ''
        };

        let settingsVisible = false;

        function toggleSettings(force) {
            const overlay = document.getElementById('settings-overlay');
            const button = document.getElementById('settings-btn');
            if (!overlay) return;

            let show;
            if (typeof force === 'boolean') {
                show = force;
            } else {
                show = overlay.classList.contains('hidden');
            }

            overlay.classList.toggle('hidden', !show);
            settingsVisible = show;

            if (button) {
                button.classList.toggle('active', show);
            }
        }

        function closeSettingsIfOpen() {
            if (settingsVisible) {
                toggleSettings(false);
            }
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeSettingsIfOpen();
            }
        });

        document.addEventListener('click', (event) => {
            if (!settingsVisible) return;
            const overlay = document.getElementById('settings-overlay');
            const panel = document.getElementById('settings-panel');
            if (!overlay || !panel) return;
            const button = document.getElementById('settings-btn');
            if (panel.contains(event.target) || (button && button.contains(event.target))) {
                return;
            }
            toggleSettings(false);
        });

        function onInputMethodChange(value) {
            setInputMethod(value);
        }

        function updateInputMethodUI() {
            const options = document.querySelectorAll('#input-method-options .radio-option');
            options.forEach((option) => {
                const input = option.querySelector('input[type="radio"]');
                if (!input) return;
                const isActive = input.value === inputState.method;
                if (input.checked !== isActive) {
                    input.checked = isActive;
                }
                option.classList.toggle('active', isActive);
            });
        }

        function updateGamepadStatus(text, connected = false) {
            const statusEl = document.getElementById('gamepad-status');
            if (statusEl) {
                statusEl.textContent = text;
            }
            inputState.gamepadConnected = connected;
        }

        function getGamepadList() {
            const getPadsFn = navigator.getGamepads || navigator.webkitGetGamepads || navigator.msGetGamepads;
            if (!getPadsFn) {
                return null;
            }
            try {
                return getPadsFn.call(navigator);
            } catch (err) {
                console.warn('Unable to query gamepads:', err);
                return null;
            }
        }

        function getActiveGamepad() {
            const pads = getGamepadList();
            if (!pads) return null;

            if (inputState.gamepadIndex !== null && pads.length > inputState.gamepadIndex) {
                const indexedPad = pads[inputState.gamepadIndex];
                if (indexedPad && indexedPad.connected) {
                    return indexedPad;
                }
            }

            const length = typeof pads.length === 'number' ? pads.length : 0;
            for (let i = 0; i < length; i++) {
                const pad = pads[i];
                if (pad && pad.connected) {
                    inputState.gamepadIndex = pad.index ?? i;
                    return pad;
                }
            }

            return null;
        }

        function stopGamepadPolling() {
            if (inputState.pollHandle) {
                cancelAnimationFrame(inputState.pollHandle);
                inputState.pollHandle = null;
            }
            inputState.lastLeft = 0;
            inputState.lastRight = 0;
            inputState.gamepadIndex = null;
        }

        function applyGamepadDeadZone(value) {
            if (Math.abs(value) < GAMEPAD_DEAD_ZONE) {
                return 0;
            }
            return Math.max(-1, Math.min(1, value));
        }

        function getGamepadAxis(gamepad, primaryIndex, fallbackIndex = null) {
            if (!gamepad || !gamepad.axes) return 0;
            const primary = gamepad.axes[primaryIndex];
            if (typeof primary === 'number' && Number.isFinite(primary)) {
                return primary;
            }
            if (fallbackIndex !== null) {
                const fallback = gamepad.axes[fallbackIndex];
                if (typeof fallback === 'number' && Number.isFinite(fallback)) {
                    return fallback;
                }
            }
            return 0;
        }

        function applySpeedCurve(value) {
            return Math.sign(value) * Math.pow(Math.abs(value), SPEED_CURVE_EXPONENT);
        }

        function processGamepadInput(gamepad) {
            if (!gamepad) {
                if (inputState.lastLeft !== 0 || inputState.lastRight !== 0) {
                    inputState.lastLeft = 0;
                    inputState.lastRight = 0;
                    setControlValues(0, 0, true);
                }
                return;
            }

            let leftPercent = 0;
            let rightPercent = 0;

            if (controlState.mode === 'joystick') {
                const rawForward = -applyGamepadDeadZone(getGamepadAxis(gamepad, 1));
                const rawTurn = applyGamepadDeadZone(getGamepadAxis(gamepad, 0)) * JOYSTICK_TURN_SENSITIVITY;
                let left = rawForward + rawTurn;
                let right = rawForward - rawTurn;
                const maxMagnitude = Math.max(1, Math.max(Math.abs(left), Math.abs(right)));
                left = applySpeedCurve(left / maxMagnitude);
                right = applySpeedCurve(right / maxMagnitude);
                leftPercent = Math.round(left * 100);
                rightPercent = Math.round(right * 100);
            } else {
                const leftRaw = -applyGamepadDeadZone(getGamepadAxis(gamepad, 1));
                const rightRaw = -applyGamepadDeadZone(getGamepadAxis(gamepad, 3, 5));
                leftPercent = Math.round(applySpeedCurve(leftRaw) * 100);
                rightPercent = Math.round(applySpeedCurve(rightRaw) * 100);
            }

            if (Math.abs(leftPercent) < SPEED_DEAD_ZONE) leftPercent = 0;
            if (Math.abs(rightPercent) < SPEED_DEAD_ZONE) rightPercent = 0;

            if (leftPercent !== inputState.lastLeft || rightPercent !== inputState.lastRight) {
                inputState.lastLeft = leftPercent;
                inputState.lastRight = rightPercent;
                setControlValues(leftPercent, rightPercent);
            }
        }

        function pollGamepad() {
            if (inputState.method !== 'xbox') {
                stopGamepadPolling();
                return;
            }

            const gamepad = getActiveGamepad();
            if (gamepad) {
                if (!inputState.gamepadConnected || inputState.gamepadName !== gamepad.id) {
                    inputState.gamepadName = gamepad.id;
                    updateGamepadStatus(`Connected: ${gamepad.id}`, true);
                }
                processGamepadInput(gamepad);
            } else {
                if (inputState.gamepadConnected) {
                    updateGamepadStatus('Gamepad disconnected.', false);
                }
                processGamepadInput(null);
            }

            inputState.pollHandle = requestAnimationFrame(pollGamepad);
        }

        function startGamepadPolling() {
            if (inputState.pollHandle) return;
            pollGamepad();
        }

        function setInputMethod(method) {
            if (method !== 'onscreen' && method !== 'xbox') {
                method = 'onscreen';
            }

            if (inputState.method === method) {
                updateInputMethodUI();
                refreshControlVisibility();
                return;
            }

            inputState.method = method;
            updateInputMethodUI();

            if (method === 'xbox') {
                if (!navigator.getGamepads) {
                    updateGamepadStatus('Gamepad API not supported in this browser.', false);
                    stopGamepadPolling();
                } else {
                    const existingPad = getActiveGamepad();
                    if (existingPad) {
                        inputState.gamepadName = existingPad.id;
                        updateGamepadStatus(`Connected: ${existingPad.id}`, true);
                    } else if (inputState.gamepadConnected && inputState.gamepadName) {
                        updateGamepadStatus(`Connected: ${inputState.gamepadName}`, true);
                    } else {
                        updateGamepadStatus('Waiting for Xbox controller...', false);
                    }
                    startGamepadPolling();
                }
                if (joystickControl) joystickControl.cancel();
                if (leftSlider) leftSlider.cancel();
                if (rightSlider) rightSlider.cancel();
                setControlValues(0, 0, true);
            } else {
                updateGamepadStatus('No gamepad detected.', false);
                stopGamepadPolling();
                setControlValues(0, 0, true);
            }

            refreshControlVisibility();
        }

        function refreshControlVisibility() {
            const tankControls = document.getElementById('tank-controls');
            const joystickControls = document.getElementById('joystick-control');

            if (!tankControls || !joystickControls) return;

            if (inputState.method === 'xbox') {
                tankControls.classList.add('hidden');
                joystickControls.classList.add('hidden');
                return;
            }

            if (controlState.mode === 'joystick') {
                tankControls.classList.add('hidden');
                joystickControls.classList.remove('hidden');
            } else {
                tankControls.classList.remove('hidden');
                joystickControls.classList.add('hidden');
            }
        }

        window.addEventListener('gamepadconnected', (event) => {
            inputState.gamepadIndex = event.gamepad.index;
            inputState.gamepadName = event.gamepad.id;
            updateGamepadStatus(`Connected: ${event.gamepad.id}`, true);
            if (inputState.method === 'xbox') {
                startGamepadPolling();
            }
        });

        window.addEventListener('gamepaddisconnected', (event) => {
            if (event.gamepad.index === inputState.gamepadIndex) {
                inputState.gamepadIndex = null;
                inputState.gamepadName = '';
            }
            updateGamepadStatus('Gamepad disconnected.', false);
            if (inputState.method === 'xbox') {
                processGamepadInput(null);
            }
        });

        socket.on('connect', () => {
            document.getElementById('connection-status').textContent = 'Connected';
            document.getElementById('connection-status').style.color = '#4CAF50';
        });
        
        socket.on('disconnect', () => {
            document.getElementById('connection-status').textContent = 'Disconnected';
            document.getElementById('connection-status').style.color = '#f44336';
        });
        
        // Camera management
        function startCameras() {
            console.log('Starting cameras...');
            document.getElementById('camera-start-overlay').style.display = 'none';
            document.getElementById('camera-error').style.display = 'none';
            
            // Start front camera
            const frontVideo = document.getElementById('front-video');
            frontVideo.onerror = function() {
                console.error('Front camera failed to load');
                document.getElementById('front-status').className = 'status-dot inactive';
                frontCameraActive = false;
                checkCameraStatus();
            };
            
            frontVideo.onload = function() {
                console.log('Front camera loaded');
                frontVideo.style.display = 'block';
                document.getElementById('front-status').className = 'status-dot active';
                frontCameraActive = true;
                camerasActive = true;
            };
            
            // Add timestamp to force reload
            frontVideo.src = '/video_feed/front?' + Date.now();
            
            // Start rear camera with delay
            setTimeout(() => {
                const rearVideo = document.getElementById('rear-video');
                rearVideo.onerror = function() {
                    console.error('Rear camera failed to load');
                    document.getElementById('rear-status').className = 'status-dot inactive';
                    rearCameraActive = false;
                };
                
                rearVideo.onload = function() {
                    console.log('Rear camera loaded');
                    rearVideo.style.display = 'block';
                    document.getElementById('rear-status').className = 'status-dot active';
                    rearCameraActive = true;
                };
                
                rearVideo.src = '/video_feed/rear?' + Date.now();
            }, 500);
            
            // Show camera status panel
            document.getElementById('camera-status').style.display = 'block';
            document.getElementById('camera-btn').classList.add('active');
            
            // Check status after 3 seconds
            setTimeout(checkCameraStatus, 3000);
        }
        
        function stopCameras() {
            console.log('Stopping cameras...');
            document.getElementById('front-video').src = '';
            document.getElementById('front-video').style.display = 'none';
            document.getElementById('rear-video').src = '';
            document.getElementById('rear-video').style.display = 'none';
            document.getElementById('camera-status').style.display = 'none';
            document.getElementById('camera-btn').classList.remove('active');
            document.getElementById('camera-start-overlay').style.display = 'block';
            
            camerasActive = false;
            frontCameraActive = false;
            rearCameraActive = false;
        }
        
        function toggleCamera() {
            if (camerasActive) {
                stopCameras();
            } else {
                startCameras();
            }
        }
        
        function retryCameras() {
            document.getElementById('camera-error').style.display = 'none';
            startCameras();
        }
        
        function checkCameraStatus() {
            if (!frontCameraActive && !rearCameraActive) {
                document.getElementById('camera-error').style.display = 'block';
                document.getElementById('error-message').textContent = 
                    'No cameras detected. Check camera connections.';
            } else if (!frontCameraActive) {
                console.warn('Front camera not available, using rear only');
            } else if (!rearCameraActive) {
                console.warn('Rear camera not available, using front only');
            }
        }
        
        // Motor control
        const controlState = {
            mode: 'tank',
            left: 0,
            right: 0
        };

        let leftSlider;
        let rightSlider;
        let joystickControl;

        function clampPercent(value) {
            if (!Number.isFinite(value)) return 0;
            return Math.max(-100, Math.min(100, Math.round(value)));
        }

        function queueMotorCommand(force = false) {
            const now = performance.now();
            const timeSinceLast = now - lastMotorSend;
            const send = () => {
                const payload = { left: -controlState.left, right: -controlState.right };
                socket.volatile.emit('motor_control', payload);
                document.getElementById('status').textContent =
                    `Speed: L=${controlState.left}% R=${controlState.right}%`;
                lastMotorSend = performance.now();
                motorSendScheduled = false;
            };

            if (force) {
                send();
                return;
            }

            if (timeSinceLast >= MOTOR_COMMAND_INTERVAL) {
                send();
            } else if (!motorSendScheduled) {
                motorSendScheduled = true;
                setTimeout(() => send(), MOTOR_COMMAND_INTERVAL - timeSinceLast);
            }
        }

        function setControlSide(side, value, force = false) {
            controlState[side] = clampPercent(value);
            queueMotorCommand(force);
        }

        function setControlValues(left, right, force = false) {
            controlState.left = clampPercent(left);
            controlState.right = clampPercent(right);
            queueMotorCommand(force);
        }

        function onControlToggle(checked) {
            setControlMode(checked ? 'joystick' : 'tank');
        }

        function setControlMode(mode) {
            if (mode !== 'tank' && mode !== 'joystick') return;
            if (controlState.mode === mode) {
                const toggleInput = document.getElementById('control-toggle');
                if (toggleInput && toggleInput.checked !== (mode === 'joystick')) {
                    toggleInput.checked = mode === 'joystick';
                }
                return;
            }

            controlState.mode = mode;

            const toggleInput = document.getElementById('control-toggle');

            if (toggleInput && toggleInput.checked !== (mode === 'joystick')) {
                toggleInput.checked = mode === 'joystick';
            }

            if (joystickControl) joystickControl.cancel();
            if (leftSlider) leftSlider.cancel();
            if (rightSlider) rightSlider.cancel();

            setControlValues(0, 0, true);
            refreshControlVisibility();
        }

        class MotorSlider {
            constructor(element, side) {
                this.thumb = element;
                this.side = side;
                this.value = 0;
                this.pointerId = null;
                this.dragging = false;
                this.track = this.thumb.parentElement;
                this.track.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                this.thumb.addEventListener('pointerdown', (e) => this.startDrag(e));
                this.thumb.addEventListener('pointermove', (e) => this.onPointerMove(e));
                this.thumb.addEventListener('pointerup', (e) => this.endDrag(e));
                this.thumb.addEventListener('pointercancel', (e) => this.endDrag(e));
                this.resetThumb(false);
            }

            startDrag(e) {
                if (controlState.mode !== 'tank' || inputState.method !== 'onscreen') return;
                e.preventDefault();
                this.dragging = true;
                this.pointerId = e.pointerId;
                this.thumb.setPointerCapture(this.pointerId);
                this.thumb.classList.add('active');
                this.thumb.style.transition = '';
                this.updateValueFromEvent(e);
            }

            onPointerMove(e) {
                if (!this.dragging || e.pointerId !== this.pointerId) return;
                this.updateValueFromEvent(e);
            }

            endDrag(e) {
                if (!this.dragging || (e && e.pointerId !== this.pointerId)) return;
                this.releasePointer();
                this.dragging = false;
                this.value = 0;
                this.resetThumb(true);
                setControlSide(this.side, this.value, true);
            }

            releasePointer() {
                if (this.pointerId !== null) {
                    try { this.thumb.releasePointerCapture(this.pointerId); } catch (err) {}
                }
                this.pointerId = null;
                this.thumb.classList.remove('active');
            }

            cancel() {
                this.releasePointer();
                this.dragging = false;
                this.value = 0;
                this.resetThumb(false);
            }

            updateValueFromEvent(e) {
                if (controlState.mode !== 'tank') return;
                const rect = this.track.getBoundingClientRect();
                const thumbHeight = this.thumb.offsetHeight;
                const range = Math.max(1, rect.height - thumbHeight);
                const y = e.clientY - rect.top - thumbHeight / 2;
                const clamped = Math.max(0, Math.min(range, y));
                this.thumb.style.top = `${clamped}px`;

                const normalized = 1 - (clamped / range);
                const symmetric = normalized * 2 - 1;
                const magnitude = Math.pow(Math.abs(symmetric), SPEED_CURVE_EXPONENT);
                const curved = symmetric >= 0 ? magnitude : -magnitude;
                let value = Math.round(curved * 100);
                if (Math.abs(value) < SPEED_DEAD_ZONE) {
                    value = 0;
                }
                this.value = Math.max(-100, Math.min(100, value));
                setControlSide(this.side, this.value);
            }

            resetThumb(animate = true) {
                const thumbHeight = this.thumb.offsetHeight;
                const range = this.track.offsetHeight - thumbHeight;
                const center = range / 2;
                this.thumb.classList.remove('active');
                if (animate) {
                    this.thumb.style.transition = 'top 0.12s ease-out';
                } else {
                    this.thumb.style.transition = '';
                }
                this.thumb.style.top = `${center}px`;
                if (animate) {
                    setTimeout(() => { this.thumb.style.transition = ''; }, 150);
                }
            }
        }

        class JoystickControl {
            constructor(baseElement, thumbElement) {
                this.base = baseElement;
                this.thumb = thumbElement;
                this.pointerId = null;
                this.active = false;

                this.base.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                this.base.addEventListener('pointerdown', (e) => this.start(e));
                this.base.addEventListener('pointermove', (e) => this.move(e));
                this.base.addEventListener('pointerup', (e) => this.end(e));
                this.base.addEventListener('pointercancel', (e) => this.end(e));
            }

            start(e) {
                if (controlState.mode !== 'joystick' || inputState.method !== 'onscreen') return;
                e.preventDefault();
                this.active = true;
                this.pointerId = e.pointerId;
                this.base.setPointerCapture(this.pointerId);
                this.thumb.style.transition = 'none';
                this.base.classList.add('active');
                this.updateFromEvent(e);
            }

            move(e) {
                if (!this.active || e.pointerId !== this.pointerId) return;
                this.updateFromEvent(e);
            }

            end(e) {
                if (!this.active || (e && e.pointerId !== this.pointerId)) return;
                if (this.pointerId !== null) {
                    try { this.base.releasePointerCapture(this.pointerId); } catch (err) {}
                }
                this.pointerId = null;
                this.active = false;
                this.reset(true);
                setControlValues(0, 0, true);
            }

            cancel() {
                if (this.pointerId !== null) {
                    try { this.base.releasePointerCapture(this.pointerId); } catch (err) {}
                }
                this.pointerId = null;
                this.active = false;
                this.reset(false);
            }

            updateFromEvent(e) {
                if (controlState.mode !== 'joystick' || inputState.method !== 'onscreen') return;
                const rect = this.base.getBoundingClientRect();
                const radius = rect.width / 2;
                if (radius <= 0) return;

                let offsetX = e.clientX - (rect.left + radius);
                let offsetY = e.clientY - (rect.top + radius);
                const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
                if (distance > radius) {
                    const scale = radius / distance;
                    offsetX *= scale;
                    offsetY *= scale;
                }

                this.thumb.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;

                const normalizedX = offsetX / radius;
                const normalizedY = -offsetY / radius;

                let forward = normalizedY;
                let turn = normalizedX * JOYSTICK_TURN_SENSITIVITY;

                let left = forward + turn;
                let right = forward - turn;

                const maxMagnitude = Math.max(1, Math.max(Math.abs(left), Math.abs(right)));
                left /= maxMagnitude;
                right /= maxMagnitude;

                let leftCurved = Math.sign(left) * Math.pow(Math.abs(left), SPEED_CURVE_EXPONENT);
                let rightCurved = Math.sign(right) * Math.pow(Math.abs(right), SPEED_CURVE_EXPONENT);

                let leftPercent = Math.round(leftCurved * 100);
                let rightPercent = Math.round(rightCurved * 100);

                if (Math.abs(leftPercent) < SPEED_DEAD_ZONE) leftPercent = 0;
                if (Math.abs(rightPercent) < SPEED_DEAD_ZONE) rightPercent = 0;

                setControlValues(leftPercent, rightPercent);
            }

            reset(animate = true) {
                this.base.classList.remove('active');
                if (animate) {
                    this.thumb.style.transition = 'transform 0.12s ease-out';
                } else {
                    this.thumb.style.transition = '';
                }
                this.thumb.style.transform = 'translate(-50%, -50%)';
                if (animate) {
                    setTimeout(() => { this.thumb.style.transition = ''; }, 150);
                }
            }
        }

        leftSlider = new MotorSlider(document.getElementById('left-thumb'), 'left');
        rightSlider = new MotorSlider(document.getElementById('right-thumb'), 'right');
        joystickControl = new JoystickControl(
            document.getElementById('joystick-base'),
            document.getElementById('joystick-thumb')
        );

        refreshControlVisibility();
        updateInputMethodUI();
        updateGamepadStatus('No gamepad detected.', false);

        function emergencyStop() {
            socket.emit('emergency_stop');
            if (leftSlider) leftSlider.cancel();
            if (rightSlider) rightSlider.cancel();
            if (joystickControl) joystickControl.cancel();
            setControlValues(0, 0, true);
            document.getElementById('status').textContent = 'STOPPED';
        }

        function shutdownCrawler() {
            if (!confirm('Shut down the crawler?\n\nAfter shutdown completes you must flip the power switch.')) {
                return;
            }

            fetch('/api/shutdown', { method: 'POST' })
                .then(res => {
                    if (!res.ok) throw new Error('Failed to request shutdown');
                    alert('Shutdown requested. Wait for the Pi to power down, then flip the main switch.');
                })
                .catch(err => {
                    console.error(err);
                    alert('Unable to request shutdown. Check connection and try again.');
                });
        }

        function changeStreamQuality(profile) {
            fetch('/api/camera/quality', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ profile })
            }).then(res => {
                if (!res.ok) throw new Error('Quality change failed');
            }).catch(err => {
                console.error(err);
                alert('Could not change camera quality.');
            });
        }

        function refreshStatus() {
            fetch('/api/status')
                .then(res => res.json())
                .then(data => {
                    if (data && data.cameras && data.cameras.profile) {
                        const select = document.getElementById('quality-select');
                        if (select && data.cameras.profile !== select.value) {
                            select.value = data.cameras.profile;
                        }
                    }
                })
                .catch(() => {});
        }

        setInterval(refreshStatus, 2000);
        refreshStatus();
    </script>
</body>
</html>
